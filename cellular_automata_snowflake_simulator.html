<!doctype html>
<html>
  <head>
    <title>Advanced Probabilistic Snowflake Crystal Growth Simulator</title>

    <meta charset="UTF-8" />
    <meta
      name="description"
      content="The goal of this page is to offer a high-performance snowflake formation simulation that actually makes images that look like REAL snowflakes, with the real world diversity and features of actual snowflakes!"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <style>
      body {
        background: radial-gradient(circle at center, #1a237e, #0d47a1, #01579b);
        overflow-x: hidden;
      }
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937;
      }
      ::-webkit-scrollbar-thumb {
        background: #374151;
        border-radius: 4px;
      }
      .datgui-reset .dg {
        z-index: 9999 !important;
      }
      canvas {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
      }
      .snowflake-canvas {
        transition: transform 0.3s ease-out;
        will-change: transform;
        backface-visibility: hidden;
        transform: translateZ(0);
        background: rgba(17, 24, 39, 0.95);
        width: 600px;
        height: 600px;
      }
      .glow-effect {
        filter: drop-shadow(0 0 12px rgba(147, 197, 253, 0.6));
      }
      .floating {
        animation: float 6s ease-in-out infinite;
      }
      .background-particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: -1;
      }
    </style>
  </head>
  <body class="text-white min-h-screen p-8 datgui-reset">
    <canvas id="backgroundParticles" class="background-particles"></canvas>
    <div class="max-w-7xl mx-auto">
      <div class="text-center mb-12 floating">
        <h1 class="text-5xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-blue-200 to-indigo-200 glow-effect">
          Advanced Probabilistic Snowflake Growth Simulator
        </h1>
        <p class="text-blue-200 opacity-80">Physics-based simulation with probabilistic crystallization, defects, and air flow</p>
      </div>
      <div class="bg-gray-800 bg-opacity-30 backdrop-blur-lg rounded-2xl p-8 shadow-2xl border border-blue-500/10">
        <div class="mb-8 bg-gray-900 bg-opacity-50 rounded-xl p-6">
          <div class="flex flex-wrap items-center gap-6 mb-4">
            <button
              id="playPauseBtn"
              class="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-lg font-semibold transition-all duration-200 flex items-center gap-2 shadow-lg hover:shadow-blue-500/20"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
                />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              Play
            </button>
            <button
              id="resetBtn"
              class="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-lg font-semibold transition-all duration-200 flex items-center gap-2 shadow-lg hover:shadow-red-500/20"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                />
              </svg>
              Reset
            </button>
            <button
              id="shuffleBtn"
              class="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-lg font-semibold transition-all duration-200 flex items-center gap-2 shadow-lg hover:shadow-purple-500/20"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                />
              </svg>
              Shuffle
            </button>
            <div id="stepCounter" class="text-xl font-mono bg-gray-800 px-4 py-2 rounded-lg shadow-inner">Step: 0 / 1000</div>
            <div class="relative">
              <select id="resolutionSelect" class="w-full bg-gray-700 text-white px-3 py-1.5 rounded-lg appearance-none cursor-pointer text-sm">
                <option value="301" selected>301×301</option>
                <option value="401">401×401</option>
                <option value="501">501×501</option>
              </select>
              <div class="absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none">
                <svg class="w-4 h-4 fill-current" viewBox="0 0 20 20">
                  <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" />
                </svg>
              </div>
            </div>
          </div>
          <input
            type="range"
            min="0"
            max="1000"
            value="0"
            class="w-full h-3 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
            id="timeSlider"
          />
        </div>
        <div class="flex justify-center">
          <canvas id="snowflakeCanvas" class="snowflake-canvas aspect-square rounded-xl shadow-lg"></canvas>
        </div>
        <div id="statisticsPanel" class="mt-6 backdrop-blur-xl bg-gray-900/80 rounded-2xl border border-blue-500/20 overflow-hidden">
          <!-- Header with gradient and glow -->
          <div class="bg-gradient-to-r from-blue-900/50 to-indigo-900/50 p-4 border-b border-blue-500/20">
            <h2 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-indigo-200 filter drop-shadow-lg">
              Simulation Statistics
            </h2>
          </div>

          <!-- Stats Content with Grid Layout -->
          <div id="statsContent" class="p-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Basic Metrics Card -->
            <div class="bg-gray-800/50 rounded-xl p-4 border border-blue-500/10 hover:border-blue-500/30 transition-colors duration-300">
              <h3 class="text-lg font-semibold mb-3 text-blue-300 flex items-center">
                <svg class="w-5 h-5 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
                  />
                </svg>
                Basic Metrics
              </h3>
              <div class="space-y-2 font-mono text-sm">
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg">
                  <span class="text-blue-200/80">Crystallized Cells</span>
                  <span id="statCrystallized" class="text-white font-bold">0</span>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg">
                  <span class="text-blue-200/80">Avg. Crystallization</span>
                  <span id="statAvgCrystallization" class="text-white font-bold">0.00</span>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg">
                  <span class="text-blue-200/80">Temperature</span>
                  <span id="statAvgTemperature" class="text-white font-bold">0.00°C</span>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg">
                  <span class="text-blue-200/80">Vapor Concentration</span>
                  <span id="statAvgVapor" class="text-white font-bold">0.00</span>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg">
                  <span class="text-blue-200/80">Step</span>
                  <span id="statStep" class="text-white font-bold">0</span>
                </div>
              </div>
            </div>

            <!-- Growth Analysis Card -->
            <div class="bg-gray-800/50 rounded-xl p-4 border border-blue-500/10 hover:border-blue-500/30 transition-colors duration-300">
              <h3 class="text-lg font-semibold mb-3 text-blue-300 flex items-center">
                <svg class="w-5 h-5 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
                Growth Analysis
              </h3>
              <div class="space-y-2 font-mono text-sm">
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg group hover:bg-gray-900/70 transition-colors">
                  <span class="text-blue-200/80">Maximum Radius</span>
                  <div class="flex items-center">
                    <span id="statMaxRadius" class="text-white font-bold">0.0</span>
                    <span class="text-blue-300/60 ml-1">units</span>
                  </div>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg group hover:bg-gray-900/70 transition-colors">
                  <span class="text-blue-200/80">Secondary Branches</span>
                  <span id="statSecondaryBranches" class="text-white font-bold">0</span>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg group hover:bg-gray-900/70 transition-colors">
                  <span class="text-blue-200/80">Surface Area</span>
                  <div class="flex items-center">
                    <span id="statSurfaceArea" class="text-white font-bold">0</span>
                    <span class="text-blue-300/60 ml-1">cells</span>
                  </div>
                </div>
                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg group hover:bg-gray-900/70 transition-colors">
                  <span class="text-blue-200/80">Symmetry</span>
                  <div class="flex items-center">
                    <span id="statSymmetry" class="text-white font-bold">0.0</span>
                    <span class="text-blue-300/60 ml-1">%</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Physical Properties Card -->
            <div class="bg-gray-800/50 rounded-xl p-4 border border-blue-500/10 hover:border-blue-500/30 transition-colors duration-300">
              <h3 class="text-lg font-semibold mb-3 text-blue-300 flex items-center">
                <svg class="w-5 h-5 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"
                  />
                </svg>
                Physical Properties
              </h3>
              <div class="space-y-2 font-mono text-sm">
                <!-- Nice circular progress indicator for defect density -->
                <div class="bg-gray-900/50 p-3 rounded-lg">
                  <div class="flex justify-between items-center mb-2">
                    <span class="text-blue-200/80">Defect Density</span>
                    <span id="statDefectDensity" class="text-white font-bold">0.0%</span>
                  </div>
                  <div class="w-full bg-gray-700/50 rounded-full h-2">
                    <div
                      id="defectDensityBar"
                      class="bg-gradient-to-r from-blue-500 to-indigo-500 h-2 rounded-full transition-all duration-300"
                      style="width: 0%"
                    ></div>
                  </div>
                </div>

                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg hover:bg-gray-900/70 transition-colors">
                  <span class="text-blue-200/80">Average Stress</span>
                  <span id="statAverageStress" class="text-white font-bold">0.000</span>
                </div>

                <div class="flex justify-between items-center bg-gray-900/50 p-2 rounded-lg hover:bg-gray-900/70 transition-colors">
                  <span class="text-blue-200/80">Boundary Layer</span>
                  <div class="flex items-center">
                    <span id="statBoundaryLayer" class="text-white font-bold">0.0</span>
                    <span class="text-blue-300/60 ml-1">μm</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Footer with additional info -->
          <div class="px-6 py-4 bg-gray-900/50 border-t border-blue-500/10">
            <div class="flex items-center justify-between text-sm text-blue-200/60">
              <div class="flex items-center">
                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  />
                </svg>
                Real-time simulation statistics
              </div>
              <div class="flex items-center">
                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Updated every frame
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // Constants and utility functions
      const PHYSICAL_CONSTANTS = {
        WATER_LATENT_HEAT: 2.83e6, // J/kg
        WATER_VAPOR_DIFFUSIVITY: 2.0e-5, // m²/s
        ICE_SURFACE_ENERGY: 0.109, // J/m²
        WATER_MOLECULAR_MASS: 18.015e-3, // kg/mol
        GAS_CONSTANT: 8.314, // J/(mol·K)
        ABSOLUTE_ZERO: 273.15, // K
        STEFAN_BOLTZMANN: 5.67e-8, // W/(m²·K⁴)
        ICE_THERMAL_CONDUCTIVITY: 2.18, // W/(m·K)
        ICE_DENSITY: 916.7, // kg/m³
        AIR_VISCOSITY: 1.81e-5, // Pa·s
        AIR_THERMAL_CONDUCTIVITY: 0.024, // W/(m·K)
        CRITICAL_REYNOLDS: 2300,
        PRANDTL_NUMBER: 0.71,
        SCHMIDT_NUMBER: 0.63,
        AIR_DENSITY: 1.225,
        MIN_TIME_STEP: 1e-6,
        MAX_TIME_STEP: 1e-2,
        MAX_ITERATIONS: 50,
        CONVERGENCE_THRESHOLD: 1e-6,
      };

      class TypedArrayPool {
        constructor(size, type = Float32Array, maxPoolSize = 100) {
          this.size = size;
          this.type = type;
          this.maxPoolSize = maxPoolSize;
          this.pool = [];
        }

        acquire() {
          return this.pool.pop() || new this.type(this.size);
        }

        release(array) {
          if (array && this.pool.length < this.maxPoolSize) {
            array.fill(0);
            this.pool.push(array);
          }
        }

        clear() {
          this.pool.length = 0;
        }
      }

      class EnhancedAnisotropySystem {
        constructor() {
          // High-resolution lookup tables for performance
          this.ANGLE_RESOLUTION = 7200; // 0.05 degree resolution
          this.surfaceEnergy = new Float32Array(this.ANGLE_RESOLUTION);
          this.attachmentKinetics = new Float32Array(this.ANGLE_RESOLUTION);
          this.mobilityFactors = new Float32Array(this.ANGLE_RESOLUTION);

          // Physical constants for ice
          this.BASAL_SURFACE_ENERGY = 0.109; // J/m² for ice basal plane
          this.PRISM_SURFACE_ENERGY = 0.109; // J/m² for prismatic plane
          this.STEP_EDGE_ENERGY = 0.055; // J/m for molecular steps

          // Temperature-dependent parameters
          this.ACTIVATION_ENERGY_BASAL = 5.5e-20; // J per molecule
          this.ACTIVATION_ENERGY_PRISM = 5.9e-20; // J per molecule

          this.setupAnisotropyTables();
        }

        setupAnisotropyTables() {
          // Enhanced multi-scale anisotropy function combining:
          // 1. Primary hexagonal symmetry
          // 2. Secondary prism face effects
          // 3. Step-edge barriers
          // 4. Surface reconstruction effects

          for (let i = 0; i < this.ANGLE_RESOLUTION; i++) {
            const angle = (i * 2 * Math.PI) / this.ANGLE_RESOLUTION;

            // Primary hexagonal symmetry (sharper than simple cos function)
            const hexSymmetry = Math.pow(Math.abs(Math.cos(3 * angle)), 4);

            // Secondary prism face effects (30° offset from primary)
            const prismEffect = 0.3 * Math.pow(Math.abs(Math.cos(3 * angle + Math.PI / 6)), 8);

            // Step-edge barrier function (creates sharp minima at specific angles)
            const stepBarrier = this.calculateStepBarrier(angle);

            // Surface reconstruction term (adds subtle complexity)
            const reconstruction = 0.1 * (Math.cos(12 * angle) + Math.cos(18 * angle));

            // Combine effects with physics-based weighting
            this.surfaceEnergy[i] =
              this.BASAL_SURFACE_ENERGY * (1.0 + 0.5 * hexSymmetry + 0.3 * prismEffect + 0.2 * stepBarrier + 0.05 * reconstruction);

            // Attachment kinetics with strong angular dependence
            this.attachmentKinetics[i] = this.calculateAttachmentKinetics(angle, hexSymmetry);

            // Surface mobility factors
            this.mobilityFactors[i] = this.calculateMobilityFactor(angle, stepBarrier);
          }
        }

        calculateStepBarrier(angle) {
          // Enhanced step-edge barrier function incorporating:
          // - Sharp barriers at primary crystallographic directions
          // - Secondary barriers at intermediate angles
          // - Smooth transitions between barriers

          const primaryAngles = Array.from({ length: 6 }, (_, i) => (i * Math.PI) / 3);
          const secondaryAngles = Array.from({ length: 6 }, (_, i) => (i * Math.PI) / 3 + Math.PI / 6);

          let barrier = 0;

          // Primary barriers (very sharp)
          for (const refAngle of primaryAngles) {
            const delta = Math.abs(((angle - refAngle + Math.PI) % (2 * Math.PI)) - Math.PI);
            barrier += Math.exp(-Math.pow(delta * 30, 2));
          }

          // Secondary barriers (more gentle)
          for (const refAngle of secondaryAngles) {
            const delta = Math.abs(((angle - refAngle + Math.PI) % (2 * Math.PI)) - Math.PI);
            barrier += 0.3 * Math.exp(-Math.pow(delta * 20, 2));
          }

          return barrier;
        }

        calculateAttachmentKinetics(angle, hexSymmetry) {
          // Enhanced attachment kinetics model incorporating:
          // - Strong preference for basal plane attachment
          // - Temperature-dependent activation barriers
          // - Surface roughness effects

          const baseRate = 0.1; // base attachment rate
          const roughnessFactor = 1.0 + 0.2 * Math.cos(12 * angle);
          const activationBarrier = this.ACTIVATION_ENERGY_BASAL * (1.0 - 0.3 * hexSymmetry);

          return baseRate * Math.exp(-activationBarrier / (1.380649e-23 * 273.15)) * roughnessFactor;
        }

        calculateMobilityFactor(angle, stepBarrier) {
          // Surface mobility model incorporating:
          // - Enhanced mobility along step edges
          // - Reduced mobility across steps
          // - Temperature dependence

          const baseMobility = 1.0;
          const stepEffect = 1.0 - 0.8 * stepBarrier;
          const temperatureFactor = Math.exp(-5000 / 273.15);

          return baseMobility * stepEffect * temperatureFactor;
        }

        getAnisotropyFactors(angle, temperature) {
          // Get interpolated values from lookup tables with temperature correction
          const idx = Math.floor(((angle + Math.PI) * this.ANGLE_RESOLUTION) / (2 * Math.PI)) % this.ANGLE_RESOLUTION;
          const tempFactor = this.calculateTemperatureFactor(temperature);

          return {
            surfaceEnergy: this.surfaceEnergy[idx] * tempFactor.energy,
            attachmentRate: this.attachmentKinetics[idx] * tempFactor.kinetics,
            mobilityFactor: this.mobilityFactors[idx] * tempFactor.mobility,
          };
        }

        calculateTemperatureFactor(temperature) {
          // Temperature dependence of various factors
          // Temperature should be in Kelvin
          const reducedTemp = temperature / 273.15;

          return {
            energy: 1.0 - 0.1 * (1.0 - reducedTemp),
            kinetics: Math.exp(-this.ACTIVATION_ENERGY_BASAL / (1.380649e-23 * temperature)),
            mobility: Math.exp(-5000 / temperature),
          };
        }

        /**
         * Calculate growth probability based on all anisotropic factors
         * @param {number} angle - Growth angle in radians
         * @param {number} temperature - Temperature in Kelvin
         * @param {number} supersaturation - Local supersaturation ratio
         * @param {number} stress - Local stress factor
         * @returns {number} Growth probability between 0 and 1
         */
        calculateGrowthProbability(angle, temperature, supersaturation, stress) {
          const factors = this.getAnisotropyFactors(angle, temperature);

          // Complex growth probability calculation incorporating all factors
          const surfaceEnergyTerm = Math.exp(-factors.surfaceEnergy / (1.380649e-23 * temperature));
          const kineticTerm = factors.attachmentRate * supersaturation;
          const mobilityTerm = factors.mobilityFactor * (1.0 - 0.2 * Math.abs(stress));

          // Combine terms with physics-based weighting
          const probability = 0.4 * surfaceEnergyTerm + 0.4 * kineticTerm + 0.2 * mobilityTerm;

          return Math.max(0, Math.min(1, probability));
        }
      }

      class BoundaryLayer {
        constructor(size) {
          console.log('Initializing BoundaryLayer with size:', size);
          this.size = size;
          this.thickness = new Float32Array(size * size);
          this.velocity = new Float32Array(size * size);
          this.temperature = new Float32Array(size * size);
          this.concentration = new Float32Array(size * size);
          this.shearStress = new Float32Array(size * size);
          this.momentumThickness = new Float32Array(size * size);
          this.displacementThickness = new Float32Array(size * size);
          this.cacheValid = new Uint8Array(size * size);
          console.log('BoundaryLayer initialization complete');
        }

        update(crystallization, airFlow, temperature, vapor) {
          const nu = PHYSICAL_CONSTANTS.AIR_VISCOSITY / PHYSICAL_CONSTANTS.AIR_DENSITY;
          const Pr = PHYSICAL_CONSTANTS.PRANDTL_NUMBER;
          const Sc = PHYSICAL_CONSTANTS.SCHMIDT_NUMBER;

          for (let i = 0; i < this.size * this.size; i++) {
            if (crystallization[i] <= 0.5) {
              this.cacheValid[i] = 0;
              continue;
            }

            if (!isFinite(airFlow.vx[i])) airFlow.vx[i] = 0;
            if (!isFinite(airFlow.vy[i])) airFlow.vy[i] = 0;

            const vx = Math.min(1, Math.max(-1, airFlow.vx[i]));
            const vy = Math.min(1, Math.max(-1, airFlow.vy[i]));
            const velocity = Math.sqrt(vx * vx + vy * vy);

            if (velocity < 1e-6) {
              this.cacheValid[i] = 0;
              continue;
            }

            const characteristic_length = 100e-6;
            const reynolds = Math.max(1e-6, (velocity * characteristic_length) / nu);

            if (reynolds < PHYSICAL_CONSTANTS.CRITICAL_REYNOLDS) {
              this.thickness[i] = 5.0 * Math.sqrt((nu * characteristic_length) / velocity);
              this.momentumThickness[i] = (0.664 * this.thickness[i]) / Math.sqrt(reynolds);
              this.displacementThickness[i] = 1.721 * this.momentumThickness[i];
            } else {
              this.thickness[i] = (0.37 * characteristic_length) / Math.pow(reynolds, 0.2);
              this.momentumThickness[i] = (0.036 * characteristic_length) / Math.pow(reynolds, 0.2);
              this.displacementThickness[i] = 1.3 * this.momentumThickness[i];
            }

            const y_plus = Math.min(30, (this.thickness[i] * velocity) / nu);
            this.velocity[i] = velocity * (1 - Math.exp(-y_plus / 5));

            const thermal_thickness = this.thickness[i] * Math.pow(Pr, -1 / 3);
            const T_wall = temperature[i];
            const T_inf = temperature[i] + 5;
            this.temperature[i] = T_wall + (T_inf - T_wall) * (1 - Math.exp((-3 * thermal_thickness) / this.thickness[i]));

            const concentration_thickness = this.thickness[i] * Math.pow(Sc, -1 / 3);
            const c_ratio = concentration_thickness / this.thickness[i];
            this.concentration[i] = vapor[i] * (1 - Math.exp(-3 * c_ratio));

            let shear;
            if (reynolds < PHYSICAL_CONSTANTS.CRITICAL_REYNOLDS) {
              shear = Math.max(0, (0.332 * PHYSICAL_CONSTANTS.AIR_VISCOSITY * velocity * Math.sqrt(reynolds)) / characteristic_length);
            } else {
              const cf = 0.0592 / Math.pow(reynolds, 0.2);
              shear = Math.max(0, 0.5 * PHYSICAL_CONSTANTS.AIR_DENSITY * velocity * velocity * cf);
            }
            this.shearStress[i] = shear;

            // Clamp values to reduce extreme variations
            this.shearStress[i] = Math.min(this.shearStress[i], 5); // arbitrary clamp
            this.velocity[i] = Math.min(Math.max(this.velocity[i], 1e-6), 1);
            this.thickness[i] = Math.min(Math.max(this.thickness[i], 1e-6), 1e-3);

            this.cacheValid[i] = 1;
          }
        }

        getBoundaryLayerProperties(idx) {
          return {
            thickness: this.thickness[idx],
            velocity: this.velocity[idx],
            temperature: this.temperature[idx],
            concentration: this.concentration[idx],
            shearStress: this.shearStress[idx],
            momentumThickness: this.momentumThickness[idx],
            displacementThickness: this.displacementThickness[idx],
          };
        }
      }

      class EnhancedVaporField {
        constructor(size) {
          this.size = size;

          // Primary fields
          this.vaporDensity = new Float32Array(size * size);
          this.vaporFlux = new Float32Array(size * size);
          this.interfaceVelocity = new Float32Array(size * size);
          this.boundaryMask = new Uint8Array(size * size);

          // Auxiliary fields for Stefan problem
          this.levelSet = new Float32Array(size * size);
          this.interfaceNormals = {
            x: new Float32Array(size * size),
            y: new Float32Array(size * size),
          };

          // Physical constants
          this.DIFFUSION_COEFFICIENT = 2.0e-5; // m²/s
          this.VAPOR_DENSITY_ICE = 917.0; // kg/m³
          this.VAPOR_DENSITY_AIR = 1.225; // kg/m³
          this.LATENT_HEAT = 2.83e6; // J/kg
          this.SURFACE_TENSION = 0.109; // J/m²
          this.MOLECULAR_MASS = 18.015e-3; // kg/mol
          this.GAS_CONSTANT = 8.314; // J/(mol·K)

          // Numerical parameters
          this.dt = 1e-6; // s
          this.dx = 1e-6; // m
          this.maxIterations = 50;
          this.convergenceTolerance = 1e-6;

          // Initialize solver matrices
          this.initializeSolverMatrices();
        }

        initializeSolverMatrices() {
          const n = this.size * this.size;
          // Sparse matrix storage for efficient computation
          this.matrix = {
            diagonal: new Float32Array(n),
            offDiagonal: new Float32Array(n * 4),
            indices: new Int32Array(n * 4),
          };
        }

        updateVaporField(crystallization, temperature, airFlow) {
          // 1. Update level set function and interface properties
          this.updateLevelSet(crystallization);
          this.computeInterfaceNormals();

          // 2. Identify and classify boundary conditions
          this.updateBoundaryConditions(crystallization, temperature);

          // 3. Solve Stefan problem with moving boundary
          this.solveStefanProblem(temperature, airFlow);

          // 4. Update vapor fluxes and interface velocities
          this.updateFluxesAndVelocities();

          // 5. Apply corrections for surface tension and kinetic effects
          this.applySurfaceEffects(temperature);
        }

        updateLevelSet(crystallization) {
          // Implement fast marching method for level set update
          for (let i = 0; i < this.size * this.size; i++) {
            const phi = crystallization[i] - 0.5;
            this.levelSet[i] = phi;

            // Compute signed distance function
            if (Math.abs(phi) < 1e-6) {
              this.boundaryMask[i] = 1;
              // Compute accurate distance near interface
              this.levelSet[i] = this.computeAccurateDistance(i, crystallization);
            } else {
              this.boundaryMask[i] = 0;
            }
          }
        }

        computeAccurateDistance(idx, crystallization) {
          const r = Math.floor(idx / this.size);
          const c = idx % this.size;
          let minDist = Infinity;

          // Search in local neighborhood for interface
          for (let dr = -2; dr <= 2; dr++) {
            for (let dc = -2; dc <= 2; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
                const nidx = nr * this.size + nc;
                if ((crystallization[nidx] - 0.5) * (crystallization[idx] - 0.5) <= 0) {
                  // Interface crosses between these points
                  const dist = Math.sqrt(dr * dr + dc * dc) * this.dx;
                  minDist = Math.min(minDist, dist);
                }
              }
            }
          }

          return Math.sign(crystallization[idx] - 0.5) * minDist;
        }

        computeInterfaceNormals() {
          // Compute normals using high-order ENO scheme
          for (let r = 2; r < this.size - 2; r++) {
            for (let c = 2; c < this.size - 2; c++) {
              const idx = r * this.size + c;
              if (this.boundaryMask[idx]) {
                // Use 5-point stencil for gradient computation
                const dx =
                  (-this.levelSet[idx + 2] + 8 * this.levelSet[idx + 1] - 8 * this.levelSet[idx - 1] + this.levelSet[idx - 2]) / (12 * this.dx);

                const dy =
                  (-this.levelSet[idx + 2 * this.size] +
                    8 * this.levelSet[idx + this.size] -
                    8 * this.levelSet[idx - this.size] +
                    this.levelSet[idx - 2 * this.size]) /
                  (12 * this.dx);

                // Normalize
                const mag = Math.sqrt(dx * dx + dy * dy);
                this.interfaceNormals.x[idx] = dx / mag;
                this.interfaceNormals.y[idx] = dy / mag;
              }
            }
          }
        }

        updateBoundaryConditions(crystallization, temperature) {
          for (let i = 0; i < this.size * this.size; i++) {
            if (this.boundaryMask[i]) {
              // Compute equilibrium vapor density at interface
              const T = temperature[i] + 273.15;
              const P_sat = 611.2 * Math.exp((17.62 * temperature[i]) / (243.12 + temperature[i]));
              const rho_eq = (P_sat * this.MOLECULAR_MASS) / (this.GAS_CONSTANT * T);

              // Apply Gibbs-Thomson effect
              const kappa = this.computeLocalCurvature(i);
              const rho_surface =
                rho_eq * Math.exp((2 * this.SURFACE_TENSION * this.MOLECULAR_MASS) / (this.GAS_CONSTANT * T * this.VAPOR_DENSITY_ICE * kappa));

              this.vaporDensity[i] = rho_surface;
            }
          }
        }

        computeLocalCurvature(idx) {
          // Compute mean curvature using level set function
          const r = Math.floor(idx / this.size);
          const c = idx % this.size;

          // Second derivatives
          const dxx = (this.levelSet[idx + 1] - 2 * this.levelSet[idx] + this.levelSet[idx - 1]) / (this.dx * this.dx);
          const dyy = (this.levelSet[idx + this.size] - 2 * this.levelSet[idx] + this.levelSet[idx - this.size]) / (this.dx * this.dx);

          // Mixed derivative
          const dxy =
            (this.levelSet[idx + 1 + this.size] -
              this.levelSet[idx - 1 + this.size] -
              (this.levelSet[idx + 1 - this.size] - this.levelSet[idx - 1 - this.size])) /
            (4 * this.dx * this.dx);

          // First derivatives
          const dx = this.interfaceNormals.x[idx];
          const dy = this.interfaceNormals.y[idx];

          // Mean curvature
          return -((1 + dy * dy) * dxx - 2 * dx * dy * dxy + (1 + dx * dx) * dyy) / (2 * Math.pow(1 + dx * dx + dy * dy, 1.5));
        }

        solveStefanProblem(temperature, airFlow) {
          // Implement semi-implicit scheme for Stefan problem
          let iteration = 0;
          let maxResidual = Infinity;

          const rho_prev = new Float32Array(this.vaporDensity);

          while (iteration < this.maxIterations && maxResidual > this.convergenceTolerance) {
            maxResidual = 0;

            // Build system matrix incorporating Stefan condition
            this.buildSystemMatrix(airFlow);

            // Solve system using BiCGSTAB method
            const solution = this.solveBiCGSTAB();

            // Update vapor density
            for (let i = 0; i < this.size * this.size; i++) {
              const change = solution[i] - this.vaporDensity[i];
              maxResidual = Math.max(maxResidual, Math.abs(change));
              this.vaporDensity[i] = solution[i];
            }

            iteration++;
          }
        }

        buildSystemMatrix(airFlow) {
          // Build sparse matrix for implicit solver
          for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
              const idx = r * this.size + c;

              if (this.boundaryMask[idx]) {
                // Dirichlet boundary condition at interface
                this.matrix.diagonal[idx] = 1.0;
                continue;
              }

              // Diffusion terms with convection
              const D = this.DIFFUSION_COEFFICIENT;
              const vx = airFlow.vx[idx];
              const vy = airFlow.vy[idx];

              // Central difference for diffusion, upwind for convection
              const dx2 = this.dx * this.dx;
              this.matrix.diagonal[idx] = ((-2 * D) / dx2) * (1 + 1) + 1 / this.dt;

              // Add convection terms with upwinding
              if (vx > 0) {
                this.matrix.diagonal[idx] += vx / this.dx;
              } else {
                this.matrix.diagonal[idx] -= vx / this.dx;
              }

              if (vy > 0) {
                this.matrix.diagonal[idx] += vy / this.dx;
              } else {
                this.matrix.diagonal[idx] -= vy / this.dx;
              }
            }
          }
        }

        solveBiCGSTAB() {
          const n = this.size * this.size;

          // Allocate vectors needed for BiCGSTAB
          const x = new Float32Array(n); // Solution vector
          const r = new Float32Array(n); // Residual
          const r0_hat = new Float32Array(n); // Initial residual
          const v = new Float32Array(n); // Search direction
          const p = new Float32Array(n); // Auxiliary vector
          const s = new Float32Array(n); // Auxiliary vector
          const t = new Float32Array(n); // Auxiliary vector

          // Initialize solution vector
          for (let i = 0; i < n; i++) {
            x[i] = this.vaporDensity[i];
          }

          // Calculate initial residual r = b - Ax
          this.computeResidual(x, r);

          // Set initial shadow residual r0_hat = r
          for (let i = 0; i < n; i++) {
            r0_hat[i] = r[i];
          }

          // Initialize other parameters
          let rho = 1.0;
          let alpha = 1.0;
          let omega = 1.0;

          // Main iteration loop
          let iter = 0;
          const maxIter = Math.min(1000, n); // Limit maximum iterations
          const tolerance = 1e-6;

          while (iter < maxIter) {
            const rho_new = this.dotProduct(r0_hat, r);

            // Beta calculation
            const beta = (rho_new / rho) * (alpha / omega);
            rho = rho_new;

            // Update p
            for (let i = 0; i < n; i++) {
              p[i] = r[i] + beta * (p[i] - omega * v[i]);
            }

            // Compute v = A*p
            this.matrixVectorProduct(p, v);

            // Compute alpha
            alpha = rho / this.dotProduct(r0_hat, v);

            // Update s = r - alpha*v
            for (let i = 0; i < n; i++) {
              s[i] = r[i] - alpha * v[i];
            }

            // Compute t = A*s
            this.matrixVectorProduct(s, t);

            // Compute omega
            const ts_dot = this.dotProduct(t, s);
            const tt_dot = this.dotProduct(t, t);
            omega = ts_dot / tt_dot;

            // Update solution and residual
            for (let i = 0; i < n; i++) {
              x[i] = x[i] + alpha * p[i] + omega * s[i];
              r[i] = s[i] - omega * t[i];
            }

            // Check convergence
            const residualNorm = this.vectorNorm(r);
            if (residualNorm < tolerance) {
              break;
            }

            // Check for breakdown
            if (Math.abs(omega) < 1e-14 || Math.abs(rho) < 1e-14) {
              // Reset to handle breakdown
              omega = 1.0;
              rho = 1.0;
              for (let i = 0; i < n; i++) {
                r[i] = this.vaporDensity[i] - x[i];
                r0_hat[i] = r[i];
              }
            }

            iter++;
          }

          return x;
        }

        computeResidual(x, r) {
          // Compute r = b - Ax for sparse matrix
          const n = this.size * this.size;

          for (let i = 0; i < n; i++) {
            // Start with b (right-hand side)
            r[i] = this.vaporDensity[i];

            // Subtract A*x using sparse matrix structure
            let sum = 0;
            // Diagonal term
            sum += this.matrix.diagonal[i] * x[i];

            // Off-diagonal terms
            for (let j = 0; j < 4; j++) {
              const neighbor_idx = this.matrix.indices[i * 4 + j];
              if (neighbor_idx >= 0 && neighbor_idx < n) {
                sum += this.matrix.offDiagonal[i * 4 + j] * x[neighbor_idx];
              }
            }

            r[i] -= sum;
          }
        }

        matrixVectorProduct(v, result) {
          // Compute result = A*v for sparse matrix
          const n = this.size * this.size;

          for (let i = 0; i < n; i++) {
            let sum = 0;

            // Diagonal term
            sum += this.matrix.diagonal[i] * v[i];

            // Off-diagonal terms
            for (let j = 0; j < 4; j++) {
              const neighbor_idx = this.matrix.indices[i * 4 + j];
              if (neighbor_idx >= 0 && neighbor_idx < n) {
                sum += this.matrix.offDiagonal[i * 4 + j] * v[neighbor_idx];
              }
            }

            result[i] = sum;
          }
        }

        dotProduct(a, b) {
          let sum = 0;
          for (let i = 0; i < a.length; i++) {
            sum += a[i] * b[i];
          }
          return sum;
        }

        vectorNorm(v) {
          return Math.sqrt(this.dotProduct(v, v));
        }

        updateFluxesAndVelocities() {
          for (let i = 0; i < this.size * this.size; i++) {
            if (this.boundaryMask[i]) {
              // Compute vapor flux at interface
              const flux = this.computeInterfaceFlux(i);
              this.vaporFlux[i] = flux;

              // Update interface velocity
              this.interfaceVelocity[i] = flux / this.VAPOR_DENSITY_ICE;
            }
          }
        }

        computeInterfaceFlux(idx) {
          const r = Math.floor(idx / this.size);
          const c = idx % this.size;

          // Compute flux using one-sided differences in normal direction
          const nx = this.interfaceNormals.x[idx];
          const ny = this.interfaceNormals.y[idx];

          // Use ENO scheme for flux computation
          let flux = 0;
          if (Math.abs(nx) > Math.abs(ny)) {
            // x-direction dominant
            const sign = Math.sign(nx);
            const stencil = this.getENOStencil(idx, sign > 0 ? 1 : -1, 0);
            flux = this.DIFFUSION_COEFFICIENT * this.computeENODerivative(stencil) * Math.abs(nx);
          } else {
            // y-direction dominant
            const sign = Math.sign(ny);
            const stencil = this.getENOStencil(idx, 0, sign > 0 ? 1 : -1);
            flux = this.DIFFUSION_COEFFICIENT * this.computeENODerivative(stencil) * Math.abs(ny);
          }

          return flux;
        }

        getENOStencil(idx, dx, dy) {
          const stencil = new Float32Array(5);
          for (let i = 0; i < 5; i++) {
            const nidx = idx + (i - 2) * (dx + dy * this.size);
            stencil[i] = this.vaporDensity[nidx];
          }
          return stencil;
        }

        computeENODerivative(stencil) {
          // 4th order ENO derivative approximation
          return (-stencil[4] + 8 * stencil[3] - 8 * stencil[1] + stencil[0]) / (12 * this.dx);
        }

        applySurfaceEffects(temperature) {
          for (let i = 0; i < this.size * this.size; i++) {
            if (this.boundaryMask[i]) {
              // Apply Hertz-Knudsen kinetic correction
              const T = temperature[i] + 273.15;
              const alpha = 1.0; // accommodation coefficient
              const v_kinetic = Math.sqrt((2 * Math.PI * this.GAS_CONSTANT * T) / this.MOLECULAR_MASS);

              this.interfaceVelocity[i] *= alpha / (alpha + (2 - alpha) * (this.DIFFUSION_COEFFICIENT / (v_kinetic * this.dx)));

              // Apply curvature correction
              const kappa = this.computeLocalCurvature(i);
              const capillaryLength = this.SURFACE_TENSION / (this.VAPOR_DENSITY_ICE * this.LATENT_HEAT);

              this.interfaceVelocity[i] *= 1 - capillaryLength * kappa;
            }
          }
        }
      }

      class DepositionPhysics {
        constructor(size) {
          console.log('Initializing DepositionPhysics with size:', size);
          this.size = size;

          // Initialize all required components
          this.boundaryLayer = new BoundaryLayer(size);
          this.vaporField = new EnhancedVaporField(size);
          this.heatTransfer = new Float32Array(size * size);
          this.massTransfer = new Float32Array(size * size);
          this.localReynolds = new Float32Array(size * size);

          // Initialize lookup tables
          this.setupLookupTables();

          // Set constants
          this.minBoundaryThickness = 1e-4;
          this.minDepositionRate = 0.0001;
          this.maxDepositionRate = 0.5;
          this.minTemperature = -50;
          this.maxTemperature = 50;

          // Initialize crystalDirections (was missing)
          this.crystalDirections = new EnhancedAnisotropySystem();

          console.log('DepositionPhysics initialization complete');
        }

        setupLookupTables() {
          console.log('Setting up lookup tables');
          this.saturationPressure = new Float32Array(1000);
          this.saturationDensity = new Float32Array(1000);
          this.diffusionCoefficient = new Float32Array(1000);

          for (let i = 0; i < 1000; i++) {
            const T = i / 10 - 50 + PHYSICAL_CONSTANTS.ABSOLUTE_ZERO;
            const temp = Math.max(-50, Math.min(50, i / 10 - 50));

            this.saturationPressure[i] = Math.max(1, 611.2 * Math.exp((17.62 * temp) / (243.12 + temp)));

            this.saturationDensity[i] = Math.max(
              1e-6,
              (this.saturationPressure[i] * PHYSICAL_CONSTANTS.WATER_MOLECULAR_MASS) / (PHYSICAL_CONSTANTS.GAS_CONSTANT * T)
            );

            this.diffusionCoefficient[i] = Math.max(1e-6, PHYSICAL_CONSTANTS.WATER_VAPOR_DIFFUSIVITY * Math.pow(T / 273.15, 1.5));
          }
        }

        calculateDepositionRate(idx, vapor, temperature, airFlow, crystallization, stress) {
          // First, validate the input index and arrays
          if (
            !this.isValidIndex(idx) ||
            !vapor ||
            !temperature ||
            !airFlow ||
            !crystallization ||
            !stress ||
            vapor.length !== this.size * this.size ||
            temperature.length !== this.size * this.size ||
            crystallization.length !== this.size * this.size ||
            stress.length !== this.size * this.size
          ) {
            console.warn('Invalid inputs to calculateDepositionRate:', {
              idx,
              hasVapor: !!vapor,
              hasTemp: !!temperature,
              hasAirFlow: !!airFlow,
              hasCrystal: !!crystallization,
              hasStress: !!stress,
            });
            return 0;
          }

          const r = Math.floor(idx / this.size);
          const c = idx % this.size;

          // Early return if cell is already highly crystallized
          if (crystallization[idx] > 0.95) {
            return 0;
          }

          // Log neighbor check for initial growth points
          let hasActiveCrystalNeighbor = false;
          let bestNeighborIdx = -1;
          let bestDist = Infinity;
          let neighborLog = [];

          // Check neighbors with proper bounds checking
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;

              const nr = r + dr;
              const nc = c + dc;

              // Validate neighbor coordinates are within bounds
              if (nr < 0 || nr >= this.size || nc < 0 || nc >= this.size) {
                continue;
              }

              const nidx = nr * this.size + nc;

              // Validate neighbor index
              if (!this.isValidIndex(nidx)) {
                continue;
              }

              neighborLog.push({
                dr,
                dc,
                crystal: crystallization[nidx],
                vapor: vapor[nidx],
                temp: temperature[nidx],
              });

              if (crystallization[nidx] > 0.5) {
                hasActiveCrystalNeighbor = true;
                const dist = Math.sqrt(dr * dr + dc * dc);
                if (dist < bestDist) {
                  bestDist = dist;
                  bestNeighborIdx = nidx;
                }
              }
            }
          }

          // Log detailed state for cells around initial seed
          const center = Math.floor(this.size / 2);
          const isSeedNeighbor = Math.abs(r - center) <= 3 && Math.abs(c - center) <= 3;

          if (isSeedNeighbor) {
            console.log(`Cell (${r - center},${c - center}) state:`, {
              hasNeighbor: hasActiveCrystalNeighbor,
              crystal: crystallization[idx],
              vapor: vapor[idx],
              temp: temperature[idx],
              neighbors: neighborLog,
            });
          }

          if (!hasActiveCrystalNeighbor || bestNeighborIdx === -1) {
            return 0;
          }

          const T = Math.max(this.minTemperature, Math.min(this.maxTemperature, temperature[idx]));
          const Tidx = Math.min(999, Math.max(0, Math.floor((T + 50) * 10)));
          const psat = this.saturationPressure[Tidx];

          if (!isFinite(psat) || psat <= 0) {
            if (isSeedNeighbor) {
              console.warn('Invalid psat:', { T, Tidx, psat });
            }
            return 0;
          }

          // Calculate supersaturation directly
          const supersaturation = vapor[idx] / psat - 1;
          if (supersaturation < 0.001) {
            if (isSeedNeighbor) {
              console.log('Low supersaturation:', { vapor: vapor[idx], psat, supersaturation });
            }
            return 0;
          }

          const nr = Math.floor(bestNeighborIdx / this.size);
          const nc = bestNeighborIdx % this.size;
          const angle = Math.atan2(r - nr, c - nc);

          const deg = ((angle * 180) / Math.PI + 360) % 360;
          const closestHexAxis = Math.round(deg / 60) * 60;
          const axisDiff = Math.min(Math.abs(deg - closestHexAxis), 360 - Math.abs(deg - closestHexAxis));
          const anisotropyFactor = 1 + 1.1 * Math.cos((axisDiff * Math.PI) / 180);

          // Convert temperature from °C to Kelvin:
          const T_kelvin = T + PHYSICAL_CONSTANTS.ABSOLUTE_ZERO;

          // We already have supersaturation as (vapor/psat - 1),
          // so let's just pass "(supersaturation + 1)" if method expects ratio>1:
          const satRatio = supersaturation + 1; // e.g. 1.0 means saturated

          let growthProb;
          try {
            // Safely call calculateGrowthProbability with error handling
            growthProb = this.crystalDirections.calculateGrowthProbability(
              angle, // in radians
              T_kelvin, // in Kelvin
              satRatio, // local supersaturation ratio
              stress[idx] // dimensionless stress
            );
          } catch (error) {
            console.warn('Error calculating growth probability:', error);
            growthProb = 0.5; // Fallback value
          }

          // Combine with anisotropyFactor if desired:
          let attachment_rate = growthProb * anisotropyFactor;

          if (!isFinite(attachment_rate) || attachment_rate <= 0) return 0;

          let bl_thickness = this.boundaryLayer.thickness[idx];
          if (!isFinite(bl_thickness) || bl_thickness <= 0) {
            bl_thickness = 1e-5;
          }

          let D_eff = this.diffusionCoefficient[Tidx];
          if (!isFinite(D_eff) || D_eff <= 0) {
            D_eff = PHYSICAL_CONSTANTS.WATER_VAPOR_DIFFUSIVITY;
          }
          D_eff *= 2.0;

          const h_m = D_eff / bl_thickness;
          if (!isFinite(h_m) || h_m <= 0) return 0;

          const diffusion_resistance = 1 / h_m;
          const kinetic_resistance = 1 / attachment_rate;
          const total_resistance = (diffusion_resistance + kinetic_resistance) / 2.0;
          let baseRate = total_resistance > 0 ? 1.0 / total_resistance : 0;

          const stability = Math.max(0.5, 1.0 - 0.1 * Math.abs(stress[idx]));
          const localCurv = this.calculateLocalCurvature(idx, crystallization);
          // Reduce curvature penalty from 0.3 to 0.2
          const curvature = 1.0 - 0.2 * localCurv;
          const anglePreference = 0.5 + 0.5 * Math.cos(3 * angle);

          let finalRate = baseRate * stability * curvature * anglePreference * (1 + supersaturation);

          finalRate = Math.max(this.minDepositionRate, Math.min(finalRate, this.maxDepositionRate * 0.8));
          finalRate *= Math.pow(1 - crystallization[idx], 0.5);
          return finalRate;
        }

        calculateLocalCurvature(idx, crystallization) {
          if (!this.isValidIndex(idx)) return 0;

          const r = Math.floor(idx / this.size);
          const c = idx % this.size;
          let sum = 0;
          let count = 0;

          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr;
              const nc = c + dc;
              if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
                const nidx = nr * this.size + nc;
                if (this.isValidIndex(nidx)) {
                  sum += Math.abs(crystallization[nidx] - crystallization[idx]);
                  count++;
                }
              }
            }
          }

          return count > 0 ? sum / count : 0;
        }

        // Helper method for index validation
        isValidIndex(idx) {
          return idx >= 0 && idx < this.size * this.size;
        }
      }

      class DefectSystem {
        constructor(size) {
          this.size = size;
          this.defects = new Float32Array(size * size);
          this.defectTypes = new Uint8Array(size * size);
          this.strainField = new Float32Array(size * size);
          this.mobilityField = new Float32Array(size * size);
          this.interactionEnergy = new Float32Array(size * size);

          this.gridSize = 10;
          this.partitions = new Map();

          this.propagationProbability = 0.3;
          this.maxDefectDensity = 0.8;
          this.healingRate = 0.05;
          this.interactionRadius = 2;
        }

        getPartitionKey(r, c) {
          const gr = Math.floor(r / this.gridSize);
          const gc = Math.floor(c / this.gridSize);
          return `${gr},${gc}`;
        }

        addToPartition(idx, r, c) {
          const key = this.getPartitionKey(r, c);
          if (!this.partitions.has(key)) {
            this.partitions.set(key, new Set());
          }
          this.partitions.get(key).add(idx);
        }

        removeFromPartition(idx, r, c) {
          const key = this.getPartitionKey(r, c);
          if (this.partitions.has(key)) {
            this.partitions.get(key).delete(idx);
            if (this.partitions.get(key).size === 0) {
              this.partitions.delete(key);
            }
          }
        }

        getNeighboringDefects(r, c) {
          const neighbors = new Set();
          const gr = Math.floor(r / this.gridSize);
          const gc = Math.floor(c / this.gridSize);

          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const key = `${gr + dr},${gc + dc}`;
              if (this.partitions.has(key)) {
                for (const idx of this.partitions.get(key)) {
                  const nr = Math.floor(idx / this.size);
                  const nc = idx % this.size;
                  const dist = Math.sqrt((nr - r) * (nr - r) + (nc - c) * (nc - c));
                  if (dist <= this.interactionRadius) {
                    neighbors.add(idx);
                  }
                }
              }
            }
          }

          return neighbors;
        }

        update(crystallization, temperature, stress) {
          // Further reduce defect propagation and max density
          this.propagationProbability = 0.05;
          this.maxDefectDensity = 0.3;

          const newDefects = new Float32Array(this.size * this.size);
          const newTypes = new Uint8Array(this.size * this.size);

          this.partitions.clear();
          this.updateStrainField(stress);

          for (let i = 0; i < this.size * this.size; i++) {
            if (crystallization[i] < 0.5) continue;

            const r = Math.floor(i / this.size);
            const c = i % this.size;

            const T = Math.max(PHYSICAL_CONSTANTS.ABSOLUTE_ZERO, temperature[i] + PHYSICAL_CONSTANTS.ABSOLUTE_ZERO);
            this.mobilityField[i] = Math.exp(-5e3 / (PHYSICAL_CONSTANTS.GAS_CONSTANT * T));

            const local_strain = this.strainField[i];
            if (Math.abs(local_strain) > 0.5 && Math.random() < 0.1) {
              newDefects[i] = Math.min(this.maxDefectDensity, this.defects[i] + 0.2 * Math.random());
              newTypes[i] = 1;
              this.addToPartition(i, r, c);
            }

            if (this.defects[i] > 0) {
              this.calculateDefectInteractions(i, r, c, newDefects, newTypes, crystallization);
            }

            if (temperature[i] > -5) {
              newDefects[i] = Math.max(0, (newDefects[i] > 0 ? newDefects[i] : this.defects[i]) - this.healingRate * this.mobilityField[i]);
            } else {
              if (newDefects[i] === 0) {
                newDefects[i] = this.defects[i];
                newTypes[i] = this.defectTypes[i];
              }
            }

            if (newDefects[i] > 0.1) {
              this.addToPartition(i, r, c);
            }
          }

          this.defects = newDefects;
          this.defectTypes = newTypes;
        }

        updateStrainField(stress) {
          const youngs_modulus = 9e9;
          const poisson_ratio = 0.33;

          for (let i = 0; i < this.size * this.size; i++) {
            const strain_xx = Math.max(-0.1, Math.min(0.1, stress[i] / youngs_modulus));

            const strain_yy = -poisson_ratio * strain_xx;

            this.strainField[i] = Math.sqrt(strain_xx * strain_xx + strain_yy * strain_yy);
          }
        }

        calculateDefectInteractions(idx, r, c, newDefects, newTypes, crystallization) {
          const neighbors = this.getNeighboringDefects(r, c);
          let interactionEnergy = 0;

          for (const nidx of neighbors) {
            if (nidx === idx) continue;

            const nr = Math.floor(nidx / this.size);
            const nc = nidx % this.size;

            if (crystallization[nidx] > 0.5 && this.defects[nidx] > 0) {
              const dr = nr - r;
              const dc = nc - c;
              const distance = Math.sqrt(dr * dr + dc * dc);

              const interaction = this.calculatePairwiseInteraction(this.defectTypes[idx], this.defectTypes[nidx], distance);

              interactionEnergy += interaction;

              if (Math.random() < this.propagationProbability * this.mobilityField[idx]) {
                newDefects[nidx] = Math.min(this.maxDefectDensity, this.defects[idx] * 0.9);
                newTypes[nidx] = this.defectTypes[idx];
              }
            }
          }

          this.interactionEnergy[idx] = interactionEnergy;
        }

        calculatePairwiseInteraction(type1, type2, distance) {
          const base_energy = 1.0 / Math.max(1e-6, distance);

          if (type1 === type2) {
            return base_energy * Math.exp(-distance / 2);
          } else {
            return -0.5 * base_energy * Math.exp(-distance / 3);
          }
        }
      }

      class ImprovedSnowflakeCA {
        constructor(size = 301, seedVariation = 0, params = {}) {
          console.log('ImprovedSnowflakeCA constructor started');

          // Validate size
          this.size = Math.max(101, Math.min(1001, size));
          this.steps = 1000;
          this.currentStep = 0;

          // Initialize parameters - now only using passed in params
          this.params = this.validateParams(params);

          // Initialize core arrays
          this.crystallization = new Float32Array(this.size * this.size);
          this.temperature = new Float32Array(this.size * this.size);
          this.vapor = new Float32Array(this.size * this.size);
          this.surfaceEnergy = new Float32Array(this.size * this.size);
          this.stress = new Float32Array(this.size * this.size);

          // Initialize physics systems
          console.log('Initializing physics systems');
          this.activeCells = new Set();
          this.crystalDirections = new EnhancedAnisotropySystem();
          this.depositionPhysics = new DepositionPhysics(this.size);
          this.defectSystem = new DefectSystem(this.size);
          this.secondaryNucleationSystem = new SecondaryNucleationSystem(this.size);
          this.airFlow = new VectorField(this.size);

          // Initialize utilities
          this.arrayPool = new TypedArrayPool(this.size * this.size, Float32Array, 50);
          this.nucleationSites = new Set();
          this.maxNucleationSites = Math.min(50, Math.floor(this.size * this.size * 0.001));

          // Initialize fields
          try {
            this.initializeFields(seedVariation);
            this.sanitizeFields();
          } catch (error) {
            console.error('Error initializing fields:', error);
            this.initializeFailsafe();
            this.sanitizeFields();
          }

          // Initialize drift state
          this.temperatureDrift = {
            current: 0,
            target: (Math.random() * 2 - 1) * this.params.tempDriftMagnitude,
            lastUpdate: 0,
          };

          this.lastUpdateTime = performance.now();
          this.frameTimings = new Array(60).fill(16.67);
          console.log('ImprovedSnowflakeCA constructor finished');
        }

        validateParams(params) {
          return {
            temperature: Math.max(-40, Math.min(0, params.temperature)),
            humidity: Math.max(0.1, Math.min(5.0, params.humidity)),
            growthSpeed: Math.max(0.1, Math.min(2.0, params.growthSpeed)),
            branchingFactor: Math.max(0, Math.min(1, params.branchingFactor)),
            noiseIntensity: Math.max(0, Math.min(1, params.noiseIntensity)),
            crystalCore: Math.max(0.1, Math.min(1, params.crystalCore)),
            edgeStability: Math.max(0.1, Math.min(1, params.edgeStability)),
            diffusionRate: Math.max(0.1, Math.min(1, params.diffusionRate)),
            latentHeatRelease: Math.max(0, Math.min(0.1, params.latentHeatRelease)),
            airFlowIntensity: Math.max(0, Math.min(1, params.airFlowIntensity)),
            defectProbability: Math.max(0, Math.min(0.5, params.defectProbability)),
            surfaceAnisotropy: Math.max(0, Math.min(1, params.surfaceAnisotropy)),
            boundaryLayerEffect: Math.max(0, Math.min(1, params.boundaryLayerEffect)),
            kineticCoefficient: Math.max(0.01, Math.min(1, params.kineticCoefficient)),
            tempDriftMagnitude: Math.max(0, Math.min(5.0, params.tempDriftMagnitude)),
            tempDriftRate: Math.max(0.001, Math.min(0.1, params.tempDriftRate)),
            tempDriftInterval: Math.max(10, Math.min(200, params.tempDriftInterval)),
          };
        }

        sanitizeFields() {
          for (let i = 0; i < this.size * this.size; i++) {
            // Sanitize main fields
            if (!isFinite(this.temperature[i])) {
              this.temperature[i] = this.params.temperature;
            }
            this.temperature[i] = Math.max(-50, Math.min(0, this.temperature[i]));

            if (!isFinite(this.vapor[i])) {
              this.vapor[i] = this.params.humidity;
            }
            this.vapor[i] = Math.max(0, Math.min(5, this.vapor[i]));

            if (!isFinite(this.stress[i])) {
              this.stress[i] = 0;
            }
            this.stress[i] = Math.max(-1, Math.min(1, this.stress[i]));

            if (!isFinite(this.crystallization[i])) {
              this.crystallization[i] = 0;
            }
            this.crystallization[i] = Math.max(0, Math.min(1, this.crystallization[i]));

            // Sanitize airflow
            if (!isFinite(this.airFlow.vx[i])) {
              this.airFlow.vx[i] = 0;
            }
            this.airFlow.vx[i] = Math.max(-1, Math.min(1, this.airFlow.vx[i]));

            if (!isFinite(this.airFlow.vy[i])) {
              this.airFlow.vy[i] = 0;
            }
            this.airFlow.vy[i] = Math.max(-1, Math.min(1, this.airFlow.vy[i]));

            // Sanitize boundary layer
            if (!isFinite(this.depositionPhysics.boundaryLayer.thickness[i])) {
              this.depositionPhysics.boundaryLayer.thickness[i] = 1e-5;
            }
            this.depositionPhysics.boundaryLayer.thickness[i] = Math.max(1e-5, Math.min(1e-3, this.depositionPhysics.boundaryLayer.thickness[i]));

            if (!isFinite(this.depositionPhysics.boundaryLayer.velocity[i])) {
              this.depositionPhysics.boundaryLayer.velocity[i] = 1e-5;
            }
            this.depositionPhysics.boundaryLayer.velocity[i] = Math.max(1e-5, Math.min(1, this.depositionPhysics.boundaryLayer.velocity[i]));
          }
        }

        generateNewTargetDrift() {
          // Generate new target drift between -maxDrift and +maxDrift
          return (Math.random() * 2 - 1) * this.temperatureDrift.maxDrift;
        }

        updateTemperatureDrift() {
          // Update drift target periodically
          if (this.currentStep - this.temperatureDrift.lastUpdate >= this.params.tempDriftInterval) {
            this.temperatureDrift.target = (Math.random() * 2 - 1) * this.params.tempDriftMagnitude;
            this.temperatureDrift.lastUpdate = this.currentStep;
          }

          // Smoothly interpolate current drift toward target
          const delta = this.temperatureDrift.target - this.temperatureDrift.current;
          this.temperatureDrift.current += delta * this.params.tempDriftRate;

          // Apply drift to ambient temperature field
          const baseTemp = this.params.temperature;
          const center = Math.floor(this.size / 2);

          for (let i = 0; i < this.size * this.size; i++) {
            const r = Math.floor(i / this.size);
            const c = i % this.size;
            const dr = r - center;
            const dc = c - center;
            const dist = Math.sqrt(dr * dr + dc * dc);
            const distFactor = Math.max(0, 1 - dist / (this.size / 2));

            // Add some spatial variation to the drift
            const spatialNoise = this.turbulentNoise(r, c, 0.1) * 0.5;

            // Temperature varies more at edges than center
            const driftEffect = this.temperatureDrift.current * (1 - 0.5 * distFactor);

            this.temperature[i] = baseTemp + driftEffect + spatialNoise;
          }
        }

        initializeFailsafe() {
          const center = Math.floor(this.size / 2);
          this.crystallization.fill(0);
          this.temperature.fill(this.params.temperature);
          this.vapor.fill(this.params.humidity);
          this.surfaceEnergy.fill(1.0);
          this.stress.fill(0);
          this.crystallization[center * this.size + center] = 1.0;

          for (let i = 0; i < 5; i++) {
            const angle = (i * Math.PI * 2) / 5;
            const radius = Math.floor(this.size / 6);
            const sx = center + Math.floor(radius * Math.cos(angle));
            const sy = center + Math.floor(radius * Math.sin(angle));
            const seedIdx = sy * this.size + sx;
            this.crystallization[seedIdx] = 0.5;
            this.nucleationSites.add(seedIdx);
            this.activeCells.add(seedIdx);
          }
        }

        initializeFields(seedVariation) {
          console.log('ImprovedSnowflakeCA.initializeFields started');
          const center = Math.floor(this.size / 2);

          for (let i = 0; i < this.size * this.size; i++) {
            const r = Math.floor(i / this.size);
            const c = i % this.size;
            const dr = r - center;
            const dc = c - center;
            const dist = Math.sqrt(dr * dr + dc * dc);
            const normDist = dist / this.size;

            const baseTemp = this.params.temperature;
            const tempGradient = -2 * normDist;
            // Reduce tempNoise amplitude from 0.01 to 0.005
            const tempNoise = this.turbulentNoise(r, c, 0.005);
            this.temperature[i] = baseTemp + tempGradient + tempNoise;

            const baseHumidity = this.params.humidity;
            const humidityGradient = -0.5 * normDist;
            // Reduce humidityNoise amplitude from 0.02 to 0.01
            const humidityNoise = this.turbulentNoise(r, c, 0.01);
            this.vapor[i] = Math.max(0, baseHumidity + humidityGradient + humidityNoise);

            const baseEnergy = 1.0;
            const energyNoise = this.turbulentNoise(r, c, 0.01);
            this.surfaceEnergy[i] = baseEnergy * (1.0 + energyNoise);

            const stressNoise = this.turbulentNoise(r, c, 0.05);
            this.stress[i] = Math.max(-0.2, Math.min(0.2, 0.05 * stressNoise));
          }

          this.createInitialSeed(center, seedVariation);
          console.log('ImprovedSnowflakeCA.initializeFields finished');
        }

        calculateTotalEnergy() {
          let energy = 0;
          for (let i = 0; i < this.size * this.size; i++) {
            energy += this.crystallization[i] * (1 + Math.abs(this.temperature[i])) + this.vapor[i];
          }
          return energy;
        }

        stabilize() {
          for (let i = 0; i < this.size * this.size; i++) {
            if (!isFinite(this.temperature[i])) {
              this.temperature[i] = this.params.temperature;
            }
            this.temperature[i] = Math.max(-40, Math.min(0, this.temperature[i]));

            if (!isFinite(this.vapor[i])) {
              this.vapor[i] = this.params.humidity;
            }
            this.vapor[i] = Math.max(0, Math.min(5, this.vapor[i]));

            if (!isFinite(this.stress[i])) {
              this.stress[i] = 0;
            }
            this.stress[i] = Math.max(-1, Math.min(1, this.stress[i]));
          }

          const margin = 2;
          const baseTemp = this.params.temperature;
          const baseVapor = this.params.humidity;

          for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < margin; j++) {
              const edges = [j * this.size + i, (this.size - 1 - j) * this.size + i, i * this.size + j, i * this.size + (this.size - 1 - j)];

              edges.forEach((idx) => {
                if (idx >= 0 && idx < this.size * this.size) {
                  this.temperature[idx] = baseTemp;
                  this.vapor[idx] = baseVapor;
                  this.stress[idx] = 0;
                }
              });
            }
          }
        }

        turbulentNoise(x, y, scale) {
          let noise = 0;
          let amplitude = 1;
          let frequency = 1;
          const persistence = 0.5;
          const octaves = 4;
          let totalAmplitude = 0;

          for (let i = 0; i < octaves; i++) {
            noise += amplitude * this.simpleNoise(x * frequency, y * frequency);
            totalAmplitude += amplitude;
            amplitude *= persistence;
            frequency *= 2;
          }

          return (noise / totalAmplitude) * scale;
        }

        simpleNoise(x, y) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;

          const xf = x - Math.floor(x);
          const yf = y - Math.floor(y);

          const u = this.fade(xf);
          const v = this.fade(yf);

          const A = (this.permutation[X] + Y) & 255;
          const B = (this.permutation[(X + 1) & 255] + Y) & 255;

          return this.lerp(
            v,
            this.lerp(u, this.grad(this.permutation[A], xf, yf), this.grad(this.permutation[B], xf - 1, yf)),
            this.lerp(u, this.grad(this.permutation[(A + 1) & 255], xf, yf - 1), this.grad(this.permutation[(B + 1) & 255], xf - 1, yf - 1))
          );
        }

        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }

        lerp(t, a, b) {
          t = Math.max(0, Math.min(1, t));
          return a + t * (b - a);
        }

        grad(hash, x, y) {
          const h = hash & 15;
          const grad_x = 1 + (h & 7);
          const grad_y = 1 + ((h >> 3) & 7);
          return (h & 8 ? -grad_x : grad_x) * x + (h & 8 ? -grad_y : grad_y) * y;
        }

        permutation = new Uint8Array([
          151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,
          247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68,
          175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
          102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109,
          198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
          28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79,
          113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
          239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
          24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        ]);

        createInitialSeed(center, variation) {
          const centerIdx = center * this.size + center;

          // Set up initial crystal at center
          this.crystallization[centerIdx] = 1.0;
          this.vapor[centerIdx] = 0;
          this.nucleationSites.add(centerIdx);
          this.activeCells.add(centerIdx);

          // Initialize boundary layer and flow fields around center
          for (let dr = -3; dr <= 3; dr++) {
            for (let dc = -3; dc <= 3; dc++) {
              const nr = center + dr;
              const nc = center + dc;
              if (this.inBounds(nr, nc)) {
                const idx = nr * this.size + nc;
                this.depositionPhysics.boundaryLayer.thickness[idx] = 1e-5;
                this.depositionPhysics.boundaryLayer.velocity[idx] = 1e-5;
                this.airFlow.vx[idx] = 1e-5;
                this.airFlow.vy[idx] = 1e-5;
              }
            }
          }

          // Add initial points along main crystal axes with larger spacing
          const mainAngles = [0, Math.PI / 3, (2 * Math.PI) / 3, Math.PI, (4 * Math.PI) / 3, (5 * Math.PI) / 3];
          for (const angle of mainAngles) {
            // Use 2 units spacing instead of 1 for better initial growth
            const dx = Math.round(2 * Math.cos(angle));
            const dy = Math.round(2 * Math.sin(angle));
            const px = center + dx;
            const py = center + dy;

            if (this.inBounds(py, px)) {
              const idx = py * this.size + px;
              this.crystallization[idx] = 0.3; // Reduced initial crystallization
              this.vapor[idx] = this.params.humidity * 0.5; // Allow some vapor
              this.nucleationSites.add(idx);
              this.activeCells.add(idx);

              // Add a wider neighborhood of active cells
              for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                  const nr = py + dr;
                  const nc = px + dc;
                  if (this.inBounds(nr, nc)) {
                    const nidx = nr * this.size + nc;
                    this.activeCells.add(nidx);

                    // Add some randomness to vapor field in active region
                    if (!this.nucleationSites.has(nidx)) {
                      this.vapor[nidx] = this.params.humidity * (0.8 + 0.4 * Math.random());
                    }

                    // Initialize boundary layer and flow fields
                    this.depositionPhysics.boundaryLayer.thickness[nidx] = 1e-5;
                    this.depositionPhysics.boundaryLayer.velocity[nidx] = 1e-5;
                    this.airFlow.vx[nidx] = 1e-5;
                    this.airFlow.vy[nidx] = 1e-5;
                  }
                }
              }
            }
          }

          // Add some intermediate points for better connectivity
          for (let i = 0; i < mainAngles.length; i++) {
            const angle = mainAngles[i] + Math.PI / 6; // 30 degree offset
            const dx = Math.round(1.5 * Math.cos(angle));
            const dy = Math.round(1.5 * Math.sin(angle));
            const px = center + dx;
            const py = center + dy;

            if (this.inBounds(py, px)) {
              const idx = py * this.size + px;
              this.activeCells.add(idx);
              this.vapor[idx] = this.params.humidity * 0.7;

              // Initialize boundary layer and flow fields for intermediate points too
              this.depositionPhysics.boundaryLayer.thickness[idx] = 1e-5;
              this.depositionPhysics.boundaryLayer.velocity[idx] = 1e-5;
              this.airFlow.vx[idx] = 1e-5;
              this.airFlow.vy[idx] = 1e-5;
            }
          }
        }

        inBounds(r, c) {
          return r >= 0 && r < this.size && c >= 0 && c < this.size;
        }

        nextStep() {
          console.log(`Executing step ${this.currentStep}`);
          const startTime = performance.now();

          try {
            // Validate and sanitize before processing
            this.sanitizeFields();
            // Validate simulation state
            if (!this.crystallization || !this.temperature || !this.vapor) {
              throw new Error('Simulation arrays not properly initialized');
            }

            // Debug current state
            console.log('Current state:', {
              crystallizationSum: this.crystallization.reduce((a, b) => a + b, 0),
              temperatureRange: {
                min: Math.min(...this.temperature),
                max: Math.max(...this.temperature),
              },
              vaporRange: {
                min: Math.min(...this.vapor),
                max: Math.max(...this.vapor),
              },
            });

            // Increment step counter
            this.currentStep = Math.min(this.steps, this.currentStep + 1);
            this.updateTemperatureDrift();

            console.log('Updating crystallization...');
            const crystalStart = performance.now();
            this.updateCrystallization();
            console.log(`Crystallization update took ${performance.now() - crystalStart}ms`);

            console.log('Updateing secondary nucleation system...');
            const secondaryNucleationStart = performance.now();
            this.secondaryNucleationSystem.updateNucleationField(this.crystallization, this.temperature, this.vapor, this.stress);
            for (let i = 0; i < this.size * this.size; i++) {
              if (this.secondaryNucleationSystem.nucleationProbability[i] > 0.5) {
                this.secondaryNucleationSystem.addNucleationSite(i);
                // Optionally jump crystallization at that site:
                if (this.crystallization[i] < 0.2) {
                  this.crystallization[i] = 0.2; // or any small seed value
                }
              }
            }
            console.log(`Secondary nucleation update took ${performance.now() - secondaryNucleationStart}ms`);

            // Update air flow less frequently
            if (this.currentStep % 2 === 0) {
              console.log('Updating air flow...');
              const airStart = performance.now();
              this.airFlow.update(this.temperature, this.crystallization);
              console.log(`Air flow update took ${performance.now() - airStart}ms`);
            }

            // Sanitize after flow update
            this.sanitizeFields();

            console.log('Updating vapor field...');
            const vaporStart = performance.now();
            this.depositionPhysics.vaporField.updateVaporField(this.crystallization, this.temperature, this.airFlow);
            console.log(`Vapor field update took ${performance.now() - vaporStart}ms`);

            // Sanitize after vapor update
            this.sanitizeFields();

            console.log('Updating defect system...');
            const defectStart = performance.now();
            this.defectSystem.update(this.crystallization, this.temperature, this.stress);
            console.log(`Defect system update took ${performance.now() - defectStart}ms`);

            console.log('Diffusing fields...');
            const diffuseStart = performance.now();
            this.diffuseFields();
            console.log(`Field diffusion took ${performance.now() - diffuseStart}ms`);

            console.log('Cleaning up nucleation sites...');
            const cleanupStart = performance.now();
            this.cleanupNucleationSites();
            console.log(`Nucleation cleanup took ${performance.now() - cleanupStart}ms`);
          } catch (error) {
            console.error('Error in simulation step:', error);
            console.error('Error details:', {
              step: this.currentStep,
              arrays: {
                crystallization: this.crystallization?.length,
                temperature: this.temperature?.length,
                vapor: this.vapor?.length,
              },
              error: error.stack,
            });
            throw error; // Re-throw to be caught by main loop
          }

          const totalTime = performance.now() - startTime;
          console.log(`Step ${this.currentStep} completed in ${totalTime}ms`);
        }

        validateState() {
          const validationResults = {
            crystallization: this.validateArray(this.crystallization, 'crystallization'),
            temperature: this.validateArray(this.temperature, 'temperature'),
            vapor: this.validateArray(this.vapor, 'vapor'),
            stress: this.validateArray(this.stress, 'stress'),
          };

          // Reset any invalid values to defaults
          for (let i = 0; i < this.size * this.size; i++) {
            if (!isFinite(this.temperature[i])) {
              this.temperature[i] = this.params.temperature;
            }
            if (!isFinite(this.vapor[i])) {
              this.vapor[i] = this.params.humidity;
            }
            if (!isFinite(this.stress[i])) {
              this.stress[i] = 0;
            }
            if (!isFinite(this.crystallization[i])) {
              this.crystallization[i] = 0;
            }
          }

          console.log('Validation results:', validationResults);
          return Object.values(validationResults).every((result) => result.valid);
        }

        validateArray(array, name) {
          if (!array) {
            return { valid: false, error: `${name} array is null` };
          }
          if (array.length !== this.size * this.size) {
            return { valid: false, error: `${name} array has wrong size` };
          }
          const hasNaN = array.some((val) => isNaN(val));
          if (hasNaN) {
            return { valid: false, error: `${name} array contains NaN` };
          }
          return { valid: true };
        }

        handleSimulationError() {
          this.initializeFailsafe();
          this.currentStep = 0;
        }

        getAverageFrameTime() {
          return this.frameTimings.reduce((a, b) => a + b, 0) / this.frameTimings.length;
        }

        updateCrystallization() {
          console.log('Starting crystallization update...');
          const startTime = performance.now();

          // Debug current state
          console.log('Current state:', {
            nucleationSites: this.nucleationSites.size,
            step: this.currentStep,
            activeFields: {
              crystallization: Boolean(this.crystallization),
              temperature: Boolean(this.temperature),
              vapor: Boolean(this.vapor),
              stress: Boolean(this.stress),
            },
          });

          const tempField = this.arrayPool.acquire();
          const vaporField = this.arrayPool.acquire();

          try {
            // Initialize processing sets
            const nextActiveCells = new Set();
            let activeCells = this.activeCells || new Set();

            // First step initialization with wider initial area
            if (this.currentStep <= 1) {
              console.log('Initializing with nucleation sites:', Array.from(this.nucleationSites));
              activeCells = new Set(this.nucleationSites);

              if (activeCells.size === 0) {
                console.warn('No nucleation sites found, adding center point');
                const center = Math.floor(this.size / 2);
                const centerIdx = center * this.size + center;
                activeCells.add(centerIdx);
                this.nucleationSites.add(centerIdx);

                // Add initial points along axes for better growth
                const mainAngles = [0, Math.PI / 3, (2 * Math.PI) / 3, Math.PI, (4 * Math.PI) / 3, (5 * Math.PI) / 3];
                for (const angle of mainAngles) {
                  const dx = Math.round(Math.cos(angle));
                  const dy = Math.round(Math.sin(angle));
                  const px = center + dx;
                  const py = center + dy;

                  if (this.inBounds(py, px)) {
                    const idx = py * this.size + px;
                    this.crystallization[idx] = 0.6;
                    activeCells.add(idx);
                    this.nucleationSites.add(idx);
                  }
                }
              }
            }

            console.log('Active cells to process:', activeCells.size);

            // Safety check for empty active cells
            if (activeCells.size === 0) {
              console.warn('No active cells to process');
              return;
            }

            // FIX: Compute a stable dt once, ensuring it's never too small
            let dt = this.adaptiveTimeStep();
            dt = Math.min(0.1, dt);
            dt = Math.max(dt, 1e-4); // minimum dt to ensure growth is not negligible

            // Process cells with enhanced error checking
            const cells = Array.from(activeCells);
            const maxCellsPerChunk = 100;
            let processedCells = 0;
            let errorCount = 0;

            for (const cellIndex of cells) {
              try {
                // Validate cell index
                if (cellIndex < 0 || cellIndex >= this.size * this.size) {
                  console.warn(`Invalid cell index: ${cellIndex}`);
                  continue;
                }

                const r = Math.floor(cellIndex / this.size);
                const c = cellIndex % this.size;

                // Process neighbors with wider radius
                for (let dr = -2; dr <= 2; dr++) {
                  for (let dc = -2; dc <= 2; dc++) {
                    const nr = r + dr;
                    const nc = c + dc;

                    if (!this.inBounds(nr, nc)) continue;

                    const neighborIndex = nr * this.size + nc;
                    if (this.crystallization[neighborIndex] >= 0.95) continue;

                    // Calculate growth with safety checks
                    try {
                      // Check if neighbor has any crystallized cells nearby
                      let hasActiveCrystalNeighbor = false;
                      for (let kr = -1; kr <= 1; kr++) {
                        for (let kc = -1; kc <= 1; kc++) {
                          const checkR = nr + kr;
                          const checkC = nc + kc;
                          if (this.inBounds(checkR, checkC)) {
                            const checkIdx = checkR * this.size + checkC;
                            if (this.crystallization[checkIdx] > 0.5) {
                              hasActiveCrystalNeighbor = true;
                              break;
                            }
                          }
                        }
                        if (hasActiveCrystalNeighbor) break;
                      }

                      if (!hasActiveCrystalNeighbor) continue;

                      const depositionRate = this.depositionPhysics.calculateDepositionRate(
                        neighborIndex,
                        this.vapor,
                        this.temperature,
                        this.airFlow,
                        this.crystallization,
                        this.stress
                      );

                      if (!isFinite(depositionRate)) {
                        console.warn(`Invalid deposition rate for cell ${neighborIndex}`);
                        continue;
                      }

                      if (depositionRate > 0) {
                        // Use the stable dt computed once
                        const growth = Math.max(0, Math.min(0.1, depositionRate * dt));

                        const oldCrystal = this.crystallization[neighborIndex];
                        const newCrystal = Math.min(1.0, oldCrystal + growth);

                        if (newCrystal > oldCrystal) {
                          this.crystallization[neighborIndex] = newCrystal;
                          this.releaseLatentHeat(neighborIndex, newCrystal - oldCrystal);
                          nextActiveCells.add(neighborIndex);

                          // Add diagonal neighbors for better coverage
                          for (let ddr = -1; ddr <= 1; ddr++) {
                            for (let ddc = -1; ddc <= 1; ddc++) {
                              const nnr = nr + ddr;
                              const nnc = nc + ddc;
                              if (this.inBounds(nnr, nnc)) {
                                nextActiveCells.add(nnr * this.size + nnc);
                              }
                            }
                          }
                        }
                      }
                    } catch (error) {
                      errorCount++;
                      if (errorCount < 5) {
                        // Limit error logging
                        console.warn(`Error processing neighbor ${neighborIndex}:`, error);
                      }
                      continue;
                    }
                  }
                }

                processedCells++;

                // Log progress periodically
                if (processedCells % maxCellsPerChunk === 0) {
                  console.log(`Processed ${processedCells}/${cells.length} cells`);

                  // Originally, this code breaks if too long:
                  // if (performance.now() - startTime > 100) {
                  //   console.warn('Processing timeout, will continue next frame');
                  //   break;
                  // }

                  // FIX: Do not break. Just warn, but continue. We must complete a full iteration
                  if (performance.now() - startTime > 100) {
                    console.warn('Processing took longer than 100ms, but continuing anyway to ensure full growth update.');
                  }
                }
              } catch (error) {
                errorCount++;
                if (errorCount < 5) {
                  console.warn(`Error processing cell ${cellIndex}:`, error);
                }
                continue;
              }
            }

            // Update fields
            console.log('Updating temperature and vapor fields...');
            for (let i = 0; i < this.size * this.size; i++) {
              tempField[i] = this.temperature[i];
              vaporField[i] = this.vapor[i];
            }

            for (let i = 0; i < this.size * this.size; i++) {
              this.temperature[i] = tempField[i];
              this.vapor[i] = vaporField[i];
            }

            // Update active cells with better fallback
            this.activeCells =
              nextActiveCells.size > 0
                ? nextActiveCells
                : new Set(
                    [...this.nucleationSites].filter((idx) => {
                      // Include cells that are crystallized or have crystallized neighbors
                      if (this.crystallization[idx] > 0) return true;
                      const r = Math.floor(idx / this.size);
                      const c = idx % this.size;
                      for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                          const nr = r + dr;
                          const nc = c + dc;
                          if (this.inBounds(nr, nc)) {
                            const nidx = nr * this.size + nc;
                            if (this.crystallization[nidx] > 0.5) return true;
                          }
                        }
                      }
                      return false;
                    })
                  );

            console.log('Update completed:', {
              processedCells,
              errorCount,
              nextActiveCells: nextActiveCells.size,
              timeElapsed: performance.now() - startTime,
            });
          } catch (error) {
            console.error('Critical error in crystallization update:', error);
            throw error;
          } finally {
            this.arrayPool.release(tempField);
            this.arrayPool.release(vaporField);
          }
        }

        // Helper method to safely check bounds
        inBounds(r, c) {
          return r >= 0 && r < this.size && c >= 0 && c < this.size;
        }

        // Adaptive time step calculation with safety checks
        adaptiveTimeStep() {
          try {
            const maxGrowthRate = 0.1;
            let dt = Math.min(PHYSICAL_CONSTANTS.MAX_TIME_STEP, Math.max(PHYSICAL_CONSTANTS.MIN_TIME_STEP, 1e-3));

            let maxRate = 0;
            let validRates = 0;

            // Sample a subset of cells for performance
            for (let i = 0; i < this.size * this.size; i += 10) {
              if (this.crystallization[i] < 0.95) {
                const rate = this.depositionPhysics.calculateDepositionRate(
                  i,
                  this.vapor,
                  this.temperature,
                  this.airFlow,
                  this.crystallization,
                  this.stress
                );

                if (isFinite(rate)) {
                  maxRate = Math.max(maxRate, rate);
                  validRates++;
                }
              }
            }

            if (validRates > 0 && maxRate > 0) {
              dt = Math.min(dt, maxGrowthRate / maxRate);
            }

            return Math.max(PHYSICAL_CONSTANTS.MIN_TIME_STEP, dt);
          } catch (error) {
            console.warn('Error in adaptiveTimeStep:', error);
            return PHYSICAL_CONSTANTS.MIN_TIME_STEP;
          }
        }

        releaseLatentHeat(idx, amount) {
          const r = Math.floor(idx / this.size);
          const c = idx % this.size;
          const heatAmount = Math.max(0, amount * this.params.latentHeatRelease * PHYSICAL_CONSTANTS.WATER_LATENT_HEAT * 0.1);

          const radius = 5;
          const centerTemp = this.temperature[idx];
          let totalHeatTransferred = 0;

          for (let dr = -radius; dr <= radius; dr++) {
            for (let dc = -radius; dc <= radius; dc++) {
              const nr = r + dr;
              const nc = c + dc;

              if (this.inBounds(nr, nc)) {
                const nidx = nr * this.size + nc;
                const dist = Math.sqrt(dr * dr + dc * dc);

                if (dist <= radius) {
                  const k_effective = PHYSICAL_CONSTANTS.ICE_THERMAL_CONDUCTIVITY * (1 - 0.5 * this.crystallization[nidx]);
                  const heatTransfer = ((heatAmount * k_effective) / (1 + dist * dist)) * Math.exp(-dist / 3);

                  this.temperature[nidx] = Math.max(-50, Math.min(0, this.temperature[nidx] + heatTransfer));

                  totalHeatTransferred += heatTransfer;

                  this.stress[nidx] += Math.max(-0.5, Math.min(0.5, heatTransfer * 0.1 * (1 - this.crystallization[nidx])));

                  this.vapor[nidx] *= Math.max(0.5, Math.min(1.0, 1 - 0.05 * heatTransfer));

                  if (
                    Math.random() < 0.01 * Math.abs(heatTransfer) &&
                    this.nucleationSites.size < this.maxNucleationSites &&
                    this.crystallization[nidx] < 0.5
                  ) {
                    this.nucleationSites.add(nidx);
                  }
                }
              }
            }
          }

          const energyError = Math.abs(heatAmount - totalHeatTransferred);
          if (energyError > 1e-6) {
            const correction = (heatAmount - totalHeatTransferred) / (Math.PI * radius * radius);

            for (let dr = -radius; dr <= radius; dr++) {
              for (let dc = -radius; dc <= radius; dc++) {
                const nr = r + dr;
                const nc = c + dc;
                if (this.inBounds(nr, nc)) {
                  const nidx = nr * this.size + nc;
                  const dist = Math.sqrt(dr * dr + dc * dc);
                  if (dist <= radius) {
                    this.temperature[nidx] += correction * Math.exp(-dist / radius);
                  }
                }
              }
            }
          }
        }

        updateFields() {
          this.airFlow.update(this.temperature, this.crystallization);
          this.defectSystem.update(this.crystallization, this.temperature, this.stress);
          this.depositionPhysics.vaporField.updateVaporField(this.crystallization, this.temperature, this.airFlow);
          this.diffuseFields();
        }

        diffuseFields() {
          const newTemp = this.arrayPool.acquire();
          const newStress = this.arrayPool.acquire();

          try {
            for (let i = 0; i < this.size * this.size; i++) {
              if (this.crystallization[i] > 0.9) {
                newTemp[i] = this.temperature[i];
                newStress[i] = this.stress[i];
                continue;
              }

              const r = Math.floor(i / this.size);
              const c = i % this.size;

              let tSum = 0,
                tCount = 0;
              let sSum = 0,
                sCount = 0;

              for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                  const nr = r + dr;
                  const nc = c + dc;

                  if (this.inBounds(nr, nc)) {
                    const nidx = nr * this.size + nc;
                    const weight = 1 - this.crystallization[nidx] * 0.5;

                    const vx = Math.min(1, Math.max(-1, this.airFlow.vx[i]));
                    const vy = Math.min(1, Math.max(-1, this.airFlow.vy[i]));

                    const flowWeight = 1 + 0.1 * (vx * dc + vy * dr);

                    tSum += this.temperature[nidx] * weight * flowWeight;
                    tCount += weight * flowWeight;

                    const crystalWeight = 1 - Math.abs(this.crystallization[i] - this.crystallization[nidx]);

                    sSum += this.stress[nidx] * weight * crystalWeight;
                    sCount += weight * crystalWeight;
                  }
                }
              }

              if (tCount > 0) {
                newTemp[i] = Math.max(-50, Math.min(0, this.temperature[i] + this.params.diffusionRate * (tSum / tCount - this.temperature[i])));
              }

              if (sCount > 0) {
                newStress[i] = Math.max(-1, Math.min(1, this.stress[i] + this.params.diffusionRate * 0.3 * (sSum / sCount - this.stress[i])));
              }
            }

            this.applyBoundaryConditions(newTemp, newStress);
          } catch (error) {
            console.error('Error in field diffusion:', error);
          } finally {
            for (let i = 0; i < this.size * this.size; i++) {
              this.temperature[i] = newTemp[i];
              this.stress[i] = newStress[i];
            }
            this.arrayPool.release(newTemp);
            this.arrayPool.release(newStress);
          }
        }

        applyBoundaryConditions(newTemp, newStress) {
          const baseTemp = this.params.temperature;
          const margin = 2;

          for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < margin; j++) {
              const turbulence = this.turbulentNoise(j, i, 0.05);
              const edgeTemp = baseTemp * (0.98 + turbulence);

              const top = j * this.size + i;
              const bottom = (this.size - 1 - j) * this.size + i;
              const left = i * this.size + j;
              const right = i * this.size + (this.size - 1 - j);

              if (top >= 0 && top < this.size * this.size) {
                newTemp[top] = edgeTemp;
                newStress[top] = 0;
              }
              if (bottom >= 0 && bottom < this.size * this.size) {
                newTemp[bottom] = edgeTemp;
                newStress[bottom] = 0;
              }
              if (left >= 0 && left < this.size * this.size) {
                newTemp[left] = edgeTemp;
                newStress[left] = 0;
              }
              if (right >= 0 && right < this.size * this.size) {
                newTemp[right] = edgeTemp;
                newStress[right] = 0;
              }
            }
          }

          for (let i = 0; i < margin; i++) {
            for (let j = 0; j < margin; j++) {
              const corners = [
                i * this.size + j,
                i * this.size + (this.size - 1 - j),
                (this.size - 1 - i) * this.size + j,
                (this.size - 1 - i) * this.size + (this.size - 1 - j),
              ];

              corners.forEach((idx) => {
                if (idx >= 0 && idx < this.size * this.size) {
                  newTemp[idx] = baseTemp;
                  newStress[idx] = 0;
                }
              });
            }
          }
        }

        cleanupNucleationSites() {
          const sitesToRemove = new Set();

          for (const idx of this.nucleationSites) {
            if (idx >= 0 && idx < this.size * this.size) {
              if (this.crystallization[idx] > 0.8 || Math.random() < 0.1 * Math.abs(this.stress[idx]) || Math.random() < 0.05) {
                sitesToRemove.add(idx);
              }

              const r = Math.floor(idx / this.size);
              const c = idx % this.size;
              let neighborCount = 0;

              for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                  const nr = r + dr;
                  const nc = c + dc;
                  if (this.inBounds(nr, nc)) {
                    const nidx = nr * this.size + nc;
                    if (this.nucleationSites.has(nidx)) {
                      neighborCount++;
                    }
                  }
                }
              }

              if (neighborCount > 5) {
                sitesToRemove.add(idx);
              }
            } else {
              sitesToRemove.add(idx);
            }
          }

          sitesToRemove.forEach((idx) => {
            this.nucleationSites.delete(idx);
          });

          while (this.nucleationSites.size > this.maxNucleationSites) {
            const idx = Array.from(this.nucleationSites)[0];
            this.nucleationSites.delete(idx);
          }
        }
      }

      class VectorField {
        constructor(size) {
          this.size = size;
          this.vx = new Float32Array(size * size);
          this.vy = new Float32Array(size * size);
          this.pressure = new Float32Array(size * size);
          this.divergence = new Float32Array(size * size);
          this.curl = new Float32Array(size * size);

          this.iterations = PHYSICAL_CONSTANTS.MAX_ITERATIONS;
          this.convergenceThreshold = PHYSICAL_CONSTANTS.CONVERGENCE_THRESHOLD;
        }

        update(temperature, crystallization) {
          this.calculateProperties(temperature, crystallization);
          this.applyBoundaryEffects(crystallization);
          this.applyIncompressibility();

          // Add velocity normalization and clamping
          const maxVelocity = 1.0; // Maximum allowed velocity
          for (let i = 0; i < this.size * this.size; i++) {
            // Calculate velocity magnitude
            const vx = this.vx[i];
            const vy = this.vy[i];
            const magnitude = Math.sqrt(vx * vx + vy * vy);

            if (magnitude > maxVelocity) {
              // Normalize and scale to max velocity
              const scale = maxVelocity / magnitude;
              this.vx[i] *= scale;
              this.vy[i] *= scale;
            }

            // Additional safety clamp
            this.vx[i] = Math.max(-maxVelocity, Math.min(maxVelocity, this.vx[i]));
            this.vy[i] = Math.max(-maxVelocity, Math.min(maxVelocity, this.vy[i]));
          }

          // Example of adding a subtle swirling motion
          const swirlFactor = 0.001;
          const centerX = Math.floor(this.size / 2);
          const centerY = Math.floor(this.size / 2);

          for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
              const idx = r * this.size + c;
              const dx = c - centerX;
              const dy = r - centerY;
              // Add swirl but maintain velocity constraints
              this.vx[idx] = Math.max(-maxVelocity, Math.min(maxVelocity, this.vx[idx] + dy * swirlFactor));
              this.vy[idx] = Math.max(-maxVelocity, Math.min(maxVelocity, this.vy[idx] - dx * swirlFactor));
            }
          }
        }

        calculateProperties(temperature, crystallization) {
          const center = Math.floor(this.size / 2);

          for (let i = 0; i < this.size * this.size; i++) {
            const r = Math.floor(i / this.size);
            const c = i % this.size;

            const tempGrad = this.getTemperatureGradient(temperature, r, c);
            this.vy[i] += tempGrad * 0.01;

            if (crystallization[i] > 0.5) {
              const obstruction = Math.min(1.0, crystallization[i] * 2);
              this.vx[i] *= 1 - obstruction;
              this.vy[i] *= 1 - obstruction;
            }

            if (r > 0 && r < this.size - 1 && c > 0 && c < this.size - 1) {
              this.divergence[i] = (this.vx[i + 1] - this.vx[i - 1] + (this.vy[i + this.size] - this.vy[i - this.size])) * 0.5;
            }

            if (r > 0 && r < this.size - 1 && c > 0 && c < this.size - 1) {
              this.curl[i] = (this.vy[i + 1] - this.vy[i - 1] - (this.vx[i + this.size] - this.vx[i - this.size])) * 0.5;
            }
          }
        }

        getTemperatureGradient(temperature, r, c) {
          if (r <= 0 || r >= this.size - 1) return 0;
          return (temperature[(r + 1) * this.size + c] - temperature[(r - 1) * this.size + c]) / 2;
        }

        applyBoundaryEffects(crystallization) {
          const margin = 2;

          for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < margin; j++) {
              const decay = (j + 1) / (margin + 1);

              const top = j * this.size + i;
              const bottom = (this.size - 1 - j) * this.size + i;
              const left = i * this.size + j;
              const right = i * this.size + (this.size - 1 - j);

              if (top >= 0 && top < this.size * this.size) {
                this.vx[top] *= decay;
                this.vy[top] *= decay;
              }
              if (bottom >= 0 && bottom < this.size * this.size) {
                this.vx[bottom] *= decay;
                this.vy[bottom] *= decay;
              }
              if (left >= 0 && left < this.size * this.size) {
                this.vx[left] *= decay;
                this.vy[left] *= decay;
              }
              if (right >= 0 && right < this.size * this.size) {
                this.vx[right] *= decay;
                this.vy[right] *= decay;
              }
            }
          }
        }

        applyIncompressibility() {
          let maxDivergence = 1.0;
          let iter = 0;
          const relaxationFactor = 0.1; // Reduced from previous value for stability

          while (maxDivergence > this.convergenceThreshold && iter < this.iterations) {
            maxDivergence = 0;

            for (let r = 1; r < this.size - 1; r++) {
              for (let c = 1; c < this.size - 1; c++) {
                const idx = r * this.size + c;

                const div = (this.vx[idx + 1] - this.vx[idx - 1] + this.vy[idx + this.size] - this.vy[idx - this.size]) * 0.5;

                maxDivergence = Math.max(maxDivergence, Math.abs(div));

                // Apply pressure correction with relaxation factor
                this.pressure[idx] -= div * relaxationFactor;

                // Limit pressure values
                this.pressure[idx] = Math.max(-1.0, Math.min(1.0, this.pressure[idx]));

                const gradientScale = 0.5 * relaxationFactor;
                // Apply velocity corrections with limits
                const maxCorrection = 0.1;
                const vxCorr = Math.max(-maxCorrection, Math.min(maxCorrection, this.pressure[idx] * gradientScale));
                const vyCorr = Math.max(-maxCorrection, Math.min(maxCorrection, this.pressure[idx] * gradientScale));

                this.vx[idx - 1] += vxCorr;
                this.vx[idx + 1] -= vxCorr;
                this.vy[idx - this.size] += vyCorr;
                this.vy[idx + this.size] -= vyCorr;
              }
            }

            iter++;
          }
        }
      }

      class ImprovedRenderer {
        constructor(canvas, size) {
          console.log('ImprovedRenderer constructor started');
          if (!canvas) {
            throw new Error('Canvas element is required');
          }
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d', {
            alpha: false,
            desynchronized: true,
          });

          this.size = size;
          this.pixelRatio = Math.min(2, window.devicePixelRatio || 1);

          // Create offscreen canvas first
          this.offscreenCanvas = document.createElement('canvas');
          this.offscreenCtx = this.offscreenCanvas.getContext('2d', {
            desynchronized: true,
          });

          // Then resize both canvases
          this.resizeCanvas();
          this.setupGradients();

          this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
          this.buffer = new Uint32Array(this.imageData.data.buffer);

          this.ctx.imageSmoothingEnabled = false;
          this.offscreenCtx.imageSmoothingEnabled = false;

          // Add resize listener
          this._resizeHandler = () => this.resizeCanvas();
          window.addEventListener('resize', this._resizeHandler);

          console.log('ImprovedRenderer constructor finished, canvas:', this.canvas, 'size:', this.canvas?.width, 'x', this.canvas?.height);
        }

        resizeOffscreenCanvas() {
          if (!this.offscreenCanvas || !this.canvas) {
            throw new Error('Canvas not properly initialized');
          }
          this.offscreenCanvas.width = this.canvas.width;
          this.offscreenCanvas.height = this.canvas.height;
          this.offscreenCtx.imageSmoothingEnabled = false;
        }

        resizeCanvas() {
          console.log('ImprovedRenderer.resizeCanvas started');
          if (!this.canvas) {
            throw new Error('Main canvas not initialized');
          }

          const rect = this.canvas.getBoundingClientRect();
          this.canvas.width = rect.width * this.pixelRatio;
          this.canvas.height = rect.height * this.pixelRatio;

          this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
          this.buffer = new Uint32Array(this.imageData.data.buffer);

          this.setupGradients();
          this.resizeOffscreenCanvas();

          console.log('ImprovedRenderer.resizeCanvas finished, size:', this.canvas.width, 'x', this.canvas.height);
        }

        cleanup() {
          // Remove event listener when the renderer is no longer needed
          window.removeEventListener('resize', this._resizeHandler);
        }

        setupGradients() {
          this.gradientCache = new Map();

          const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
          coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
          coreGradient.addColorStop(0.7, 'rgba(220, 235, 255, 0.8)');
          coreGradient.addColorStop(1, 'rgba(180, 210, 255, 0.0)');
          this.gradientCache.set('core', coreGradient);

          const edgeGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
          edgeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
          edgeGradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.5)');
          edgeGradient.addColorStop(1, 'rgba(150, 180, 255, 0.0)');
          this.gradientCache.set('edge', edgeGradient);

          const defectGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
          defectGradient.addColorStop(0, 'rgba(255, 100, 100, 0.6)');
          defectGradient.addColorStop(0.5, 'rgba(255, 150, 150, 0.3)');
          defectGradient.addColorStop(1, 'rgba(255, 200, 200, 0.0)');
          this.gradientCache.set('defect', defectGradient);

          const tempGradient = this.ctx.createLinearGradient(0, 0, 0, 1);
          tempGradient.addColorStop(0, 'rgba(0, 150, 255, 0.2)');
          tempGradient.addColorStop(0.5, 'rgba(0, 100, 255, 0.1)');
          tempGradient.addColorStop(1, 'rgba(0, 50, 255, 0.0)');
          this.gradientCache.set('temperature', tempGradient);
        }

        draw(snowflake, width, height) {
          this.offscreenCtx.fillStyle = '#111827';
          this.offscreenCtx.fillRect(0, 0, width, height);

          const scale = (Math.min(width, height) / snowflake.size) * 0.9;
          const offsetX = width / 2;
          const offsetY = height / 2;

          this.offscreenCtx.save();
          this.offscreenCtx.translate(offsetX, offsetY);

          this.drawTemperatureField(snowflake, scale);
          this.drawCrystalStructure(snowflake, scale);
          this.drawDefects(snowflake, scale);
          this.drawSurfaceDetails(snowflake, scale);
          this.drawAirFlow(snowflake, scale);
          this.drawFrostingEffect(snowflake, scale);
          this.drawBoundaryLayer(snowflake, scale);

          this.offscreenCtx.restore();

          this.applyPostProcessing(width, height);

          this.ctx.clearRect(0, 0, width, height);
          this.ctx.drawImage(this.offscreenCanvas, 0, 0);
        }

        drawTemperatureField(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'screen';
          const center = Math.floor(snowflake.size / 2);

          for (let r = 0; r < snowflake.size; r++) {
            for (let c = 0; c < snowflake.size; c++) {
              const idx = r * snowflake.size + c;
              const temp = snowflake.temperature[idx];

              if (temp < 0) {
                const dx = (c - center) * scale;
                const dy = (r - center) * scale;

                const intensity = Math.pow(-temp / 50, 0.5);
                this.offscreenCtx.fillStyle = `rgba(0, ${Math.floor(100 + 100 * intensity)}, ${Math.floor(200 + 55 * intensity)}, ${0.1 * intensity})`;

                this.offscreenCtx.beginPath();
                this.offscreenCtx.arc(dx, dy, scale * 1.5, 0, Math.PI * 2);
                this.offscreenCtx.fill();
              }
            }
          }
        }

        drawCrystalStructure(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'screen';
          const center = Math.floor(snowflake.size / 2);

          for (let r = 0; r < snowflake.size; r++) {
            for (let c = 0; c < snowflake.size; c++) {
              const idx = r * snowflake.size + c;
              const crystal = snowflake.crystallization[idx];

              if (crystal > 0.1) {
                const dx = (c - center) * scale;
                const dy = (r - center) * scale;

                const gradient = this.offscreenCtx.createRadialGradient(dx, dy, 0, dx, dy, scale * 1.2);

                const alpha = Math.pow(crystal, 1.5);
                const temp = snowflake.temperature[idx];
                const tempFactor = Math.max(0, -temp / 20);

                gradient.addColorStop(0, `rgba(${255 - 20 * tempFactor}, ${255 - 10 * tempFactor}, 255, ${alpha * 0.9})`);
                gradient.addColorStop(0.5, `rgba(${200 - 20 * tempFactor}, ${220 - 10 * tempFactor}, 255, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(147, 197, 253, 0)');

                this.offscreenCtx.fillStyle = gradient;
                this.offscreenCtx.beginPath();
                this.offscreenCtx.arc(dx, dy, scale * 1.2, 0, Math.PI * 2);
                this.offscreenCtx.fill();
              }
            }
          }
        }

        drawDefects(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'overlay';
          const center = Math.floor(snowflake.size / 2);

          for (let r = 0; r < snowflake.size; r++) {
            for (let c = 0; c < snowflake.size; c++) {
              const idx = r * snowflake.size + c;
              const defect = snowflake.defectSystem.defects[idx];

              if (defect > 0.1) {
                const dx = (c - center) * scale;
                const dy = (r - center) * scale;

                const defectType = snowflake.defectSystem.defectTypes[idx];
                const stress = Math.abs(snowflake.stress[idx]);

                let defectColor;
                switch (defectType) {
                  case 1:
                    defectColor = `rgba(255, ${100 + 50 * stress}, ${100 + 25 * stress}, ${defect * 0.4})`;
                    break;
                  default:
                    defectColor = `rgba(255, ${200 + 25 * stress}, ${200 + 25 * stress}, ${defect * 0.3})`;
                }

                this.offscreenCtx.fillStyle = defectColor;
                this.offscreenCtx.beginPath();
                this.offscreenCtx.arc(dx, dy, scale * 0.6, 0, Math.PI * 2);
                this.offscreenCtx.fill();

                if (stress > 0.2) {
                  const lineCount = Math.floor(4 + stress * 4);
                  this.offscreenCtx.strokeStyle = `rgba(255, 150, 150, ${defect * 0.2})`;
                  this.offscreenCtx.lineWidth = scale * 0.1;

                  for (let i = 0; i < lineCount; i++) {
                    const angle = (i / lineCount) * Math.PI * 2;
                    const length = scale * (0.8 + stress * 0.5);

                    this.offscreenCtx.beginPath();
                    this.offscreenCtx.moveTo(dx + Math.cos(angle) * scale * 0.7, dy + Math.sin(angle) * scale * 0.7);
                    this.offscreenCtx.lineTo(dx + Math.cos(angle) * length, dy + Math.sin(angle) * length);
                    this.offscreenCtx.stroke();
                  }
                }
              }
            }
          }
        }

        drawSurfaceDetails(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'overlay';
          const center = Math.floor(snowflake.size / 2);

          for (let r = 0; r < snowflake.size; r++) {
            for (let c = 0; c < snowflake.size; c++) {
              const idx = r * snowflake.size + c;
              if (snowflake.crystallization[idx] > 0.5) {
                const dx = (c - center) * scale;
                const dy = (r - center) * scale;
                const stress = Math.abs(snowflake.stress[idx]);

                if (stress > 0.1) {
                  const gradient = this.offscreenCtx.createRadialGradient(dx, dy, 0, dx, dy, scale * 0.6);

                  gradient.addColorStop(0, `rgba(180, 200, 255, ${stress * 0.4})`);
                  gradient.addColorStop(0.7, `rgba(160, 180, 255, ${stress * 0.2})`);
                  gradient.addColorStop(1, 'rgba(140, 160, 255, 0)');

                  this.offscreenCtx.fillStyle = gradient;
                  this.offscreenCtx.beginPath();
                  this.offscreenCtx.arc(dx, dy, scale * 0.6, 0, Math.PI * 2);
                  this.offscreenCtx.fill();
                }
              }
            }
          }
        }

        drawAirFlow(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'soft-light';
          const center = Math.floor(snowflake.size / 2);

          const stepSize = 4;
          const particleCount = 100;
          const maxSteps = 50;

          for (let i = 0; i < particleCount; i++) {
            let x = Math.random() * snowflake.size;
            let y = Math.random() * snowflake.size;

            this.offscreenCtx.beginPath();
            this.offscreenCtx.moveTo((x - center) * scale, (y - center) * scale);

            for (let step = 0; step < maxSteps; step++) {
              const idx = Math.floor(y) * snowflake.size + Math.floor(x);
              if (idx < 0 || idx >= snowflake.size * snowflake.size) break;

              const vx = snowflake.airFlow.vx[idx];
              const vy = snowflake.airFlow.vy[idx];
              const speed = Math.sqrt(vx * vx + vy * vy);

              if (speed < 0.01) break;

              x += vx * stepSize;
              y += vy * stepSize;

              if (x < 0 || x >= snowflake.size || y < 0 || y >= snowflake.size) break;

              this.offscreenCtx.lineTo((x - center) * scale, (y - center) * scale);
            }

            this.offscreenCtx.strokeStyle = `rgba(147, 197, 253, ${0.05 + Math.random() * 0.05})`;
            this.offscreenCtx.lineWidth = scale * 0.15;
            this.offscreenCtx.stroke();
          }
        }

        drawFrostingEffect(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'overlay';
          const center = Math.floor(snowflake.size / 2);

          for (let r = 0; r < snowflake.size; r++) {
            for (let c = 0; c < snowflake.size; c++) {
              const idx = r * snowflake.size + c;
              if (snowflake.crystallization[idx] > 0.8) {
                const dx = (c - center) * scale;
                const dy = (r - center) * scale;

                const temp = snowflake.temperature[idx];
                const frostIntensity = Math.max(0, -temp / 20);

                if (Math.random() < 0.3 * frostIntensity) {
                  const highlight = Math.random() * 0.4 * frostIntensity;
                  const size = scale * (0.1 + Math.random() * 0.1);

                  this.offscreenCtx.fillStyle = `rgba(255, 255, 255, ${highlight})`;
                  this.offscreenCtx.beginPath();
                  this.offscreenCtx.arc(dx + (Math.random() - 0.5) * scale * 0.3, dy + (Math.random() - 0.5) * scale * 0.3, size, 0, Math.PI * 2);
                  this.offscreenCtx.fill();
                }
              }
            }
          }
        }

        drawBoundaryLayer(snowflake, scale) {
          this.offscreenCtx.globalCompositeOperation = 'multiply';
          const center = Math.floor(snowflake.size / 2);

          if (!snowflake.depositionPhysics?.boundaryLayer?.thickness) {
            return;
          }

          for (let r = 0; r < snowflake.size; r++) {
            for (let c = 0; c < snowflake.size; c++) {
              const idx = r * snowflake.size + c;
              if (snowflake.crystallization[idx] > 0.5) {
                const dx = (c - center) * scale;
                const dy = (r - center) * scale;

                const thickness = snowflake.depositionPhysics.boundaryLayer.thickness[idx];
                if (thickness > 0) {
                  const gradient = this.offscreenCtx.createRadialGradient(dx, dy, 0, dx, dy, thickness * scale);

                  gradient.addColorStop(0, 'rgba(180, 200, 255, 0.1)');
                  gradient.addColorStop(0.7, 'rgba(160, 180, 255, 0.05)');
                  gradient.addColorStop(1, 'rgba(140, 160, 255, 0)');

                  this.offscreenCtx.fillStyle = gradient;
                  this.offscreenCtx.beginPath();
                  this.offscreenCtx.arc(dx, dy, thickness * scale, 0, Math.PI * 2);
                  this.offscreenCtx.fill();
                }
              }
            }
          }
        }

        applyPostProcessing(width, height) {
          this.offscreenCtx.globalCompositeOperation = 'screen';
          this.offscreenCtx.filter = 'blur(8px)';
          this.offscreenCtx.drawImage(this.offscreenCanvas, 0, 0);
          this.offscreenCtx.filter = 'none';

          const gradient = this.offscreenCtx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 1.5);

          gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');

          this.offscreenCtx.globalCompositeOperation = 'multiply';
          this.offscreenCtx.fillStyle = gradient;
          this.offscreenCtx.fillRect(0, 0, width, height);

          this.offscreenCtx.globalCompositeOperation = 'source-over';
        }
      }

      class SecondaryNucleationSystem {
        constructor(size) {
          this.size = size;

          // Core fields
          this.nucleationSites = new Set();
          this.nucleationProbability = new Float32Array(size * size);
          this.branchingDirections = new Float32Array(size * size);
          this.siteAge = new Map(); // Track age of nucleation sites
          this.branchHistory = new Map(); // Track branch hierarchy

          // Physical parameters
          this.CRITICAL_SUPERSATURATION = 0.05; // Minimum supersaturation for nucleation
          this.CRITICAL_CURVATURE = 0.2; // Maximum curvature for stable nucleation
          this.MIN_SITE_SPACING = 3; // Minimum spacing between nucleation sites
          this.MAX_BRANCHING_ANGLE = Math.PI / 3; // Maximum deviation from primary directions
          this.ACTIVATION_ENERGY = 5.5e-20; // J per molecule
          this.BOLTZMANN = 1.380649e-23; // J/K

          // Branching parameters
          this.PRIMARY_DIRECTIONS = [0, Math.PI / 3, (2 * Math.PI) / 3, Math.PI, (4 * Math.PI) / 3, (5 * Math.PI) / 3];
          this.branchGenerations = new Map(); // Track branch hierarchy level
          this.maxBranchGeneration = 4; // Limit recursive branching

          // Initialize branch probability tables
          this.initializeProbabilityTables();
        }

        initializeProbabilityTables() {
          // Create lookup tables for angle-dependent nucleation probabilities
          this.angleProbabilities = new Float32Array(360);
          for (let i = 0; i < 360; i++) {
            const angle = (i * Math.PI) / 180;
            // Enhanced probability near primary directions
            let maxProb = 0;
            for (const primaryDir of this.PRIMARY_DIRECTIONS) {
              const angleDiff = Math.abs(((angle - primaryDir + Math.PI) % (2 * Math.PI)) - Math.PI);
              const prob = Math.exp(-Math.pow(angleDiff * 5, 2));
              maxProb = Math.max(maxProb, prob);
            }
            this.angleProbabilities[i] = maxProb;
          }
        }

        updateNucleationField(crystallization, temperature, vapor, stress) {
          // Clear old probabilities
          this.nucleationProbability.fill(0);

          // Update existing sites
          this.updateExistingSites(crystallization);

          // Find new potential nucleation sites
          for (let i = 0; i < this.size * this.size; i++) {
            if (crystallization[i] > 0.5) continue; // Skip already crystallized cells

            const { r, c } = this.indexToCoords(i);
            if (this.isValidNucleationSite(r, c, crystallization, vapor)) {
              const prob = this.calculateNucleationProbability(r, c, crystallization, temperature, vapor, stress);
              this.nucleationProbability[i] = prob;
            }
          }
        }

        isValidNucleationSite(r, c, crystallization, vapor) {
          // Check if location is suitable for nucleation

          // Must have at least one crystallized neighbor
          let hasNeighbor = false;
          let localSupersaturation = 0;
          let tooClose = false;

          // Check wider neighborhood
          for (let dr = -2; dr <= 2; dr++) {
            for (let dc = -2; dc <= 2; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (!this.inBounds(nr, nc)) continue;

              const idx = nr * this.size + nc;
              if (crystallization[idx] > 0.5) {
                // Check immediate neighborhood
                if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) {
                  hasNeighbor = true;
                }
                // Check minimum spacing requirement
                if (Math.sqrt(dr * dr + dc * dc) < this.MIN_SITE_SPACING) {
                  tooClose = true;
                }
              }
              localSupersaturation = Math.max(localSupersaturation, vapor[idx]);
            }
          }

          return hasNeighbor && !tooClose && localSupersaturation > this.CRITICAL_SUPERSATURATION;
        }

        calculateNucleationProbability(r, c, crystallization, temperature, vapor, stress) {
          const idx = r * this.size + c;

          // Get local environment characteristics
          const localGeometry = this.analyzeLocalGeometry(r, c, crystallization);
          const localSupersaturation = this.calculateLocalSupersaturation(r, c, vapor);
          const localStress = Math.abs(stress[idx]);

          // Calculate base probability from physical parameters
          const T = temperature[idx] + 273.15; // Convert to Kelvin
          const energyBarrier = this.calculateEnergyBarrier(localSupersaturation, localGeometry.curvature, T);

          let probability = Math.exp(-energyBarrier / (this.BOLTZMANN * T));

          // Apply geometric factors
          probability *= this.getAngleProbability(localGeometry.angle);
          probability *= this.getBranchingHierarchyFactor(r, c);

          // Apply environmental modifiers
          probability *= Math.max(0, 1 - localGeometry.curvature / this.CRITICAL_CURVATURE);
          probability *= Math.max(0, 1 - localStress * 2);

          // Normalize to [0,1] range
          return Math.max(0, Math.min(1, probability));
        }

        analyzeLocalGeometry(r, c, crystallization) {
          // Calculate local geometric properties
          let angle = 0;
          let curvature = 0;
          let weightedDx = 0;
          let weightedDy = 0;
          let totalWeight = 0;

          // Analyze wider neighborhood for better direction estimation
          for (let dr = -3; dr <= 3; dr++) {
            for (let dc = -3; dc <= 3; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (!this.inBounds(nr, nc)) continue;

              const idx = nr * this.size + nc;
              if (crystallization[idx] > 0.5) {
                const weight = 1 / (1 + Math.sqrt(dr * dr + dc * dc));
                weightedDx += dc * weight;
                weightedDy += dr * weight;
                totalWeight += weight;
              }
            }
          }

          if (totalWeight > 0) {
            angle = Math.atan2(weightedDy, weightedDx);
            // Calculate local curvature using discrete Laplacian
            curvature = this.calculateLocalCurvature(r, c, crystallization);
          }

          return { angle, curvature };
        }

        calculateLocalCurvature(r, c, crystallization) {
          let sum = 0;
          let count = 0;

          // Use 5-point stencil for better curvature estimation
          const stencil = [
            { dr: -1, dc: 0, weight: 1 },
            { dr: 1, dc: 0, weight: 1 },
            { dr: 0, dc: -1, weight: 1 },
            { dr: 0, dc: 1, weight: 1 },
            { dr: 0, dc: 0, weight: -4 },
          ];

          for (const { dr, dc, weight } of stencil) {
            const nr = r + dr;
            const nc = c + dc;
            if (!this.inBounds(nr, nc)) continue;

            sum += crystallization[nr * this.size + nc] * weight;
            count++;
          }

          return count > 0 ? Math.abs(sum / count) : 0;
        }

        calculateLocalSupersaturation(r, c, vapor) {
          let sum = 0;
          let count = 0;

          // Calculate average supersaturation in neighborhood
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (!this.inBounds(nr, nc)) continue;

              sum += vapor[nr * this.size + nc];
              count++;
            }
          }

          return count > 0 ? sum / count : 0;
        }

        calculateEnergyBarrier(supersaturation, curvature, temperature) {
          // Calculate nucleation energy barrier based on classical nucleation theory
          const surfaceEnergy = 0.109 * (1 + 0.1 * curvature); // J/m²
          const volume = 3.27e-29; // m³ per molecule

          // Critical nucleus size
          const criticalSize = (2 * surfaceEnergy * volume) / (this.BOLTZMANN * temperature * Math.log(1 + supersaturation));

          // Energy barrier
          return (
            (16 * Math.PI * Math.pow(surfaceEnergy, 3) * Math.pow(volume, 2)) /
            (3 * Math.pow(this.BOLTZMANN * temperature * Math.log(1 + supersaturation), 2))
          );
        }

        getAngleProbability(angle) {
          // Convert angle to lookup table index
          const idx = Math.floor(((angle + Math.PI) * 180) / Math.PI) % 360;
          return this.angleProbabilities[idx];
        }

        getBranchingHierarchyFactor(r, c) {
          const idx = r * this.size + c;
          const generation = this.branchGenerations.get(idx) || 0;

          // Decrease probability for higher-generation branches
          return Math.pow(0.7, generation);
        }

        updateExistingSites(crystallization) {
          // Update and clean up nucleation sites
          for (const site of this.nucleationSites) {
            const age = this.siteAge.get(site) || 0;

            if (crystallization[site] > 0.9 || age > 100) {
              // Site fully crystallized or too old
              this.nucleationSites.delete(site);
              this.siteAge.delete(site);
              this.branchHistory.delete(site);
            } else {
              this.siteAge.set(site, age + 1);
            }
          }
        }

        addNucleationSite(idx, parentSite = null) {
          if (this.nucleationSites.size >= this.size * this.size * 0.1) return false;

          this.nucleationSites.add(idx);
          this.siteAge.set(idx, 0);

          // Update branch hierarchy
          if (parentSite !== null) {
            const parentGen = this.branchGenerations.get(parentSite) || 0;
            if (parentGen < this.maxBranchGeneration) {
              this.branchGenerations.set(idx, parentGen + 1);
              this.branchHistory.set(idx, parentSite);
            }
          } else {
            this.branchGenerations.set(idx, 0);
          }

          return true;
        }

        inBounds(r, c) {
          return r >= 0 && r < this.size && c >= 0 && c < this.size;
        }

        indexToCoords(idx) {
          return {
            r: Math.floor(idx / this.size),
            c: idx % this.size,
          };
        }
      }

      let simulator = null;
      let renderer = null;
      let currentSize = 301;
      let isPlaying = false;
      let currentStep = 0;

      const controls = {
        temperature: -19, // Keep this as baseline
        humidity: 4.5, // Increase baseline supersaturation
        growthSpeed: 1.8, // Reduce for more detailed features
        branchingFactor: 0.98, // Increase hexagonal preference
        noiseIntensity: 0.05, // Reduce random noise
        crystalCore: 0.6, // Larger initial seed
        edgeStability: 0.98, // More stable edges
        diffusionRate: 0.4, // Slower diffusion
        latentHeatRelease: 0.01, // More local heating effects
        airFlowIntensity: 0.2, // Gentler flow
        defectProbability: 0.05, // Fewer defects
        surfaceAnisotropy: 0.8, // Stronger crystal axis preference
        boundaryLayerEffect: 0.4, // Stronger boundary layer
        kineticCoefficient: 0.2, // Slower attachment kinetics
        adaptiveTimeStepping: true,
        visualDetail: 'high',
        tempDriftMagnitude: 3.0,
        tempDriftRate: 0.02,
        tempDriftInterval: 50,
      };

      function setupGUI() {
        const gui = new dat.GUI({ width: 300 });

        const envFolder = gui.addFolder('Environment');
        envFolder.add(controls, 'temperature', -30, 0, 0.5).name('Temperature (°C)').onChange(updateParams);
        envFolder.add(controls, 'humidity', 0.5, 4.0, 0.1).name('Humidity').onChange(updateParams);
        envFolder.add(controls, 'airFlowIntensity', 0, 1, 0.05).name('Air Flow').onChange(updateParams);
        envFolder.add(controls, 'tempDriftMagnitude', 0, 5, 0.1).name('Temp Variation').onChange(updateParams);
        envFolder.add(controls, 'tempDriftRate', 0.001, 0.1, 0.001).name('Variation Rate').onChange(updateParams);
        envFolder.add(controls, 'tempDriftInterval', 10, 200, 5).name('Variation Interval').onChange(updateParams);
        envFolder.open();

        const growthFolder = gui.addFolder('Growth Parameters');
        growthFolder.add(controls, 'growthSpeed', 0.1, 2.0, 0.1).name('Growth Speed').onChange(updateParams);
        growthFolder.add(controls, 'branchingFactor', 0, 1, 0.05).name('Branching').onChange(updateParams);
        growthFolder.add(controls, 'surfaceAnisotropy', 0, 1, 0.05).name('Anisotropy').onChange(updateParams);
        growthFolder.add(controls, 'boundaryLayerEffect', 0, 1, 0.05).name('Boundary Layer').onChange(updateParams);
        growthFolder.open();

        const physicsFolder = gui.addFolder('Physics');
        physicsFolder.add(controls, 'diffusionRate', 0, 1, 0.05).name('Diffusion Rate').onChange(updateParams);
        physicsFolder.add(controls, 'latentHeatRelease', 0, 0.1, 0.01).name('Latent Heat').onChange(updateParams);
        physicsFolder.add(controls, 'kineticCoefficient', 0, 1, 0.05).name('Kinetics').onChange(updateParams);
        physicsFolder.add(controls, 'adaptiveTimeStepping').name('Adaptive Time Step').onChange(updateParams);

        const visualFolder = gui.addFolder('Visualization');
        visualFolder.add(controls, 'visualDetail', ['low', 'medium', 'high']).name('Detail Level').onChange(updateRenderer);

        return gui;
      }

      function updateParams() {
        if (simulator) {
          Object.assign(simulator.params, controls);
        }
      }

      function updateRenderer() {
        if (renderer && renderer.setDetailLevel) {
          renderer.setDetailLevel(controls.visualDetail);
        }
      }

      function createSimulator(size) {
        try {
          const canvas = document.getElementById('snowflakeCanvas');
          if (!canvas) {
            throw new Error('Could not find snowflake canvas element');
          }

          if (renderer && renderer.cleanup) {
            renderer.cleanup();
          }

          renderer = new ImprovedRenderer(canvas, size);
          simulator = new ImprovedSnowflakeCA(size, Math.random(), controls); // Pass controls here
          updateSimulation();
        } catch (error) {
          console.error('Error creating simulator:', error);
          const container = document.getElementById('snowflakeCanvas').parentElement;
          if (container) {
            container.innerHTML = `
                        <div class="p-4 bg-red-500 bg-opacity-20 rounded-lg text-white">
                            Error initializing simulation: ${error.message}
                            Please refresh the page.
                        </div>
                    `;
          }
        }
      }

      function updateSimulation() {
        PerformanceMonitor.start('updateSimulation');

        const stepCounter = document.getElementById('stepCounter');
        if (stepCounter) {
          stepCounter.textContent = `Step: ${currentStep} / 1,000`;
        }

        if (simulator && renderer) {
          try {
            PerformanceMonitor.start('render');
            renderer.draw(simulator, renderer.canvas.width, renderer.canvas.height);
            updateStatisticsPanel(simulator);
            PerformanceMonitor.end('render');
          } catch (error) {
            console.error('Render error:', error);
            isPlaying = false;
          }
        }

        PerformanceMonitor.end('updateSimulation');
      }

      function togglePlayPause() {
        isPlaying = !isPlaying;
        const btn = document.getElementById('playPauseBtn');
        btn.innerHTML = isPlaying
          ? `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                 </svg>Pause`
          : `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                 </svg>Play`;
      }

      function resetSimulation() {
        isPlaying = false;
        const btn = document.getElementById('playPauseBtn');
        btn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
             </svg>Play`;

        currentStep = 0;
        document.getElementById('timeSlider').value = 0;
        createSimulator(currentSize);
        updateSimulation();
      }

      function shuffleParameters() {
        controls.temperature = -10 - Math.random() * 15;
        controls.humidity = 1.0 + Math.random() * 2.5;
        controls.growthSpeed = 0.5 + Math.random() * 1.0;
        controls.branchingFactor = 0.3 + Math.random() * 0.7;
        controls.noiseIntensity = 0.1 + Math.random() * 0.4;
        controls.crystalCore = 0.2 + Math.random() * 0.6;
        controls.edgeStability = 0.4 + Math.random() * 0.6;
        controls.airFlowIntensity = 0.2 + Math.random() * 0.4;
        controls.defectProbability = 0.05 + Math.random() * 0.15;

        resetSimulation();
      }

      function handleSliderInput(event) {
        currentStep = parseInt(event.target.value);
        updateSimulation();
      }

      function handleResolutionChange(event) {
        currentSize = parseInt(event.target.value);
        createSimulator(currentSize);
        currentStep = 0;
        document.getElementById('timeSlider').value = 0;
        updateSimulation();
      }

      class ParticleSystem {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.particles = [];
          this.lastTime = performance.now();

          this.resize();
          window.addEventListener('resize', () => this.resize());
        }

        resize() {
          const dpr = window.devicePixelRatio || 1;
          this.canvas.width = window.innerWidth * dpr;
          this.canvas.height = window.innerHeight * dpr;

          this.ctx.scale(dpr, dpr);

          this.canvas.style.width = window.innerWidth + 'px';
          this.canvas.style.height = window.innerHeight + 'px';

          this.init();
        }

        init() {
          this.particles = [];
          const particleCount = Math.floor((this.canvas.width * this.canvas.height) / 15000);

          for (let i = 0; i < particleCount; i++) {
            this.particles.push({
              x: Math.random() * window.innerWidth,
              y: Math.random() * window.innerHeight,
              size: Math.random() * 2 + 1,
              speedX: Math.random() * 0.3 - 0.15,
              speedY: -Math.random() * 0.3 - 0.15,
              opacity: Math.random() * 0.3 + 0.1,
              pulse: Math.random() * Math.PI * 2,
              growthRate: Math.random() * 0.1 + 0.05,
              maxSize: Math.random() * 3 + 2,
            });
          }
        }

        update() {
          const currentTime = performance.now();
          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;

          this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
          const time = currentTime / 1000;

          this.particles.forEach((particle) => {
            particle.x += particle.speedX * 60 * deltaTime;
            particle.y += particle.speedY * 60 * deltaTime;

            if (particle.x < 0) particle.x = window.innerWidth;
            if (particle.x > window.innerWidth) particle.x = 0;
            if (particle.y < 0) particle.y = window.innerHeight;
            if (particle.y > window.innerHeight) particle.y = 0;

            const twinkle = 0.5 + 0.5 * Math.sin(time * 2 + particle.pulse);
            const finalOpacity = particle.opacity * twinkle;

            const sizeOscillation = Math.sin(time * particle.growthRate + particle.pulse);
            const currentSize = particle.size + sizeOscillation * 0.5;

            const gradient = this.ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, currentSize * 1.5);

            gradient.addColorStop(0, `rgba(255, 255, 255, ${finalOpacity})`);
            gradient.addColorStop(0.5, `rgba(200, 220, 255, ${finalOpacity * 0.5})`);
            gradient.addColorStop(1, 'rgba(147, 197, 253, 0)');

            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, currentSize * 1.5, 0, Math.PI * 2);
            this.ctx.fill();
          });

          requestAnimationFrame(() => this.update());
        }
      }

      function isSecondaryBranch(idx, simulator) {
        const r = Math.floor(idx / simulator.size);
        const c = idx % simulator.size;
        let connectedComponents = 0;

        // Count number of connected crystallized regions
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr;
            const nc = c + dc;
            if (simulator.inBounds(nr, nc)) {
              const nidx = nr * simulator.size + nc;
              if (simulator.crystallization[nidx] > 0.5) {
                connectedComponents++;
              }
            }
          }
        }

        // Secondary branches typically have 1-2 connections
        return connectedComponents <= 2;
      }

      function isPerimeterCell(idx, simulator) {
        const r = Math.floor(idx / simulator.size);
        const c = idx % simulator.size;

        // Check if this cell has any non-crystallized neighbors
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const nr = r + dr;
            const nc = c + dc;
            if (simulator.inBounds(nr, nc)) {
              const nidx = nr * simulator.size + nc;
              if (simulator.crystallization[nidx] < 0.5) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function updateStatisticsPanel(simulator) {
        if (!simulator) return;

        // Basic statistics
        let crystalCount = 0;
        let sumCrystallization = 0;
        let sumTemperature = 0;
        let sumVapor = 0;

        // Advanced metrics
        let primaryBranchLength = 0;
        let secondaryBranchCount = 0;
        let maxRadius = 0;
        let surfaceArea = 0;
        let boundaryLayerThickness = 0;
        let defectDensity = 0;
        let averageStress = 0;
        let growthSymmetry = 0;

        const center = Math.floor(simulator.size / 2);
        const totalCells = simulator.size * simulator.size;

        // Calculate hexagonal sectors for symmetry analysis
        const sectors = Array(6).fill(0);

        // Main data collection loop
        for (let r = 0; r < simulator.size; r++) {
          for (let c = 0; c < simulator.size; c++) {
            const idx = r * simulator.size + c;
            const crys = simulator.crystallization[idx];

            sumCrystallization += crys;
            if (crys > 0.5) {
              crystalCount++;

              // Calculate distance from center
              const dr = r - center;
              const dc = c - center;
              const dist = Math.sqrt(dr * dr + dc * dc);
              maxRadius = Math.max(maxRadius, dist);

              // Determine sector (0-5) and accumulate mass
              const angle = Math.atan2(dr, dc);
              const sector = Math.floor(((angle + Math.PI) * 3) / Math.PI) % 6;
              sectors[sector] += crys;

              if (isSecondaryBranch(idx, simulator)) {
                secondaryBranchCount++;
              }

              if (isPerimeterCell(idx, simulator)) {
                surfaceArea++;
              }
            }

            sumTemperature += simulator.temperature[idx];
            sumVapor += simulator.vapor[idx];

            if (simulator.defectSystem) {
              defectDensity += simulator.defectSystem.defects[idx];
            }
            if (simulator.stress) {
              averageStress += Math.abs(simulator.stress[idx]);
            }
            if (simulator.depositionPhysics?.boundaryLayer) {
              boundaryLayerThickness += simulator.depositionPhysics.boundaryLayer.thickness[idx];
            }
          }
        }

        // Calculate final values
        const avgCrystallization = sumCrystallization / totalCells;
        const avgTemperature = sumTemperature / totalCells;
        const avgVapor = sumVapor / totalCells;
        const defectPercentage = (defectDensity / crystalCount) * 100;
        const avgStress = averageStress / crystalCount;
        const boundaryThickness = (boundaryLayerThickness / crystalCount) * 1e6;

        // Calculate growth symmetry (0-1, where 1 is perfect symmetry)
        const avgSectorMass = sectors.reduce((a, b) => a + b, 0) / 6;
        const maxDeviation = sectors.reduce((max, mass) => Math.max(max, Math.abs(mass - avgSectorMass)), 0);
        growthSymmetry = 1 - maxDeviation / avgSectorMass;

        // Update DOM elements and visual elements together
        const updates = {
          statCrystallized: crystalCount,
          statAvgCrystallization: avgCrystallization.toFixed(4),
          statAvgTemperature: avgTemperature.toFixed(2),
          statAvgVapor: avgVapor.toFixed(3),
          statMaxRadius: maxRadius.toFixed(1),
          statSecondaryBranches: secondaryBranchCount,
          statSurfaceArea: surfaceArea,
          statSymmetry: (growthSymmetry * 100).toFixed(1),
          statDefectDensity: defectPercentage.toFixed(1),
          statAverageStress: avgStress.toFixed(3),
          statBoundaryLayer: boundaryThickness.toFixed(1),
          statStep: simulator.currentStep,
        };

        // Update all stats and their associated visual elements
        Object.entries(updates).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) {
            if (id === 'statDefectDensity') {
              // Update both text and progress bar
              element.textContent = `${value}%`;
              const bar = document.getElementById('defectDensityBar');
              if (bar) {
                const percentage = parseFloat(value);
                bar.style.width = `${percentage}%`;
                // Update bar color based on value
                bar.className =
                  'h-2 rounded-full transition-all duration-300 bg-gradient-to-r ' +
                  (percentage < 30 ? 'from-blue-500 to-indigo-500' : percentage < 70 ? 'from-yellow-500 to-orange-500' : 'from-red-500 to-red-700');
              }
            } else {
              // Regular stat update
              element.textContent = value;
            }
          }
        });
      }

      // Performance monitoring wrapper
      const PerformanceMonitor = {
        metrics: new Map(),
        startTime: null,

        start(label) {
          if (!this.metrics.has(label)) {
            this.metrics.set(label, {
              totalTime: 0,
              calls: 0,
              maxTime: 0,
            });
          }
          this.startTime = performance.now();
        },

        end(label) {
          const endTime = performance.now();
          const duration = endTime - this.startTime;
          const metric = this.metrics.get(label);
          metric.totalTime += duration;
          metric.calls++;
          metric.maxTime = Math.max(metric.maxTime, duration);

          if (duration > 100) {
            // Log long operations
            console.warn(`Long operation detected: ${label} took ${duration.toFixed(2)}ms`);
          }
        },

        reset() {
          this.metrics.clear();
        },

        report() {
          console.log('Performance Report:');
          this.metrics.forEach((metric, label) => {
            const avgTime = metric.totalTime / metric.calls;
            console.log(`${label}:
                        Calls: ${metric.calls}
                        Avg Time: ${avgTime.toFixed(2)}ms
                        Max Time: ${metric.maxTime.toFixed(2)}ms`);
          });
        },
      };

      // Optimized main loop with chunked processing
      function mainLoop() {
        try {
          if (isPlaying && simulator) {
            console.log('--- Starting new frame ---');

            // Validate simulator state before proceeding
            if (!simulator.validateState()) {
              throw new Error('Invalid simulator state detected');
            }

            const frameStart = performance.now();
            simulator.nextStep();
            const frameTime = performance.now() - frameStart;

            console.log(`Frame completed in ${frameTime}ms`);

            currentStep++;
            if (currentStep > 1000) {
              currentStep = 0;
              isPlaying = false;
            }

            // Update UI
            const slider = document.getElementById('timeSlider');
            if (slider) slider.value = currentStep;

            // Schedule rendering
            requestAnimationFrame(() => {
              const renderStart = performance.now();
              updateSimulation();
              console.log(`Render completed in ${performance.now() - renderStart}ms`);
            });
          }

          // Schedule next frame
          requestAnimationFrame(mainLoop);
        } catch (error) {
          console.error('Critical simulation error:', error);
          isPlaying = false;
          handleSimulationError(error);
        }
      }

      // Error handler
      function handleSimulationError(error) {
        console.error('Simulation error details:', {
          error: error.message,
          stack: error.stack,
          simulatorState: simulator
            ? {
                step: simulator.currentStep,
                size: simulator.size,
                arrayLengths: {
                  crystallization: simulator.crystallization?.length,
                  temperature: simulator.temperature?.length,
                  vapor: simulator.vapor?.length,
                },
              }
            : 'simulator not initialized',
        });

        const playButton = document.getElementById('playPauseBtn');
        if (playButton) {
          playButton.innerHTML = `
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                        </svg>
                        Error
                    `;
          playButton.classList.add('bg-red-600');
        }

        // Show error to user
        const errorDiv = document.createElement('div');
        errorDiv.className = 'fixed bottom-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg';
        errorDiv.textContent = `Simulation error: ${error.message}`;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 5000);
      }

      document.addEventListener('DOMContentLoaded', () => {
        try {
          // Add event listeners with passive option where appropriate
          document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause, { passive: true });
          document.getElementById('resetBtn').addEventListener('click', resetSimulation, { passive: true });
          document.getElementById('shuffleBtn').addEventListener('click', shuffleParameters, { passive: true });
          document.getElementById('timeSlider').addEventListener('input', handleSliderInput, { passive: true });
          document.getElementById('resolutionSelect').addEventListener('change', handleResolutionChange, { passive: true });

          const gui = setupGUI();

          createSimulator(currentSize);
          updateSimulation();

          const particleSystem = new ParticleSystem(document.getElementById('backgroundParticles'));
          particleSystem.update();

          // Start main loop with performance monitoring
          console.log('Starting main simulation loop...');
          mainLoop();
        } catch (error) {
          console.error('Initialization error:', error);
          const container = document.getElementById('snowflakeCanvas').parentElement;
          if (container) {
            container.innerHTML = `
                            <div class="p-4 bg-red-500 bg-opacity-20 rounded-lg text-white">
                                Error initializing simulation: ${error.message}
                                <pre class="mt-2 text-sm opacity-75">${error.stack}</pre>
                            </div>
                        `;
          }
        }
      });
    </script>
  </body>
</html>
